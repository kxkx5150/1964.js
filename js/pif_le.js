// Generated by CoffeeScript 2.5.1
(function() {
  /*1964js - JavaScript/HTML5 port of 1964 - N64 emulator
  Copyright (C) 2012 Joel Middendorf

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.*/
  //jslint todo: true, bitwise: true, devel: true, browser: true
  //globals consts, log
  "use strict";
  var C1964jsPifLE, root;

  C1964jsPifLE = class C1964jsPifLE extends C1964jsPif {
    processPif() {
      var cmd, count, device, pifRamStart;
      cmd = void 0;
      device = 0;
      count = 0;
      pifRamStart = consts.MEMORY_START_PIF_RAM - consts.MEMORY_START_PIF;
      if ((this.pifUint8Array[pifRamStart ^ 3] === 0xff) && (this.pifUint8Array[(pifRamStart + 1) ^ 3] === 0xff) && (this.pifUint8Array[(pifRamStart + 2) ^ 3] === 0xff) && (this.pifUint8Array[(pifRamStart + 3) ^ 3] === 0xff)) { //see iPif.cpp. the first 4 dwords will be -1, not just the first 4 bytes. Make pifUint32Array and use it 4 times.
        
        //todo: pif ram decryption
        throw Error("todo: decrypt");
      }
      count = 0;
      while (count < 64) {
        cmd = this.pifUint8Array[(pifRamStart + count) ^ 3];
        if (cmd === 0xFE) { //Command block ready
          break;
        //no-op commands (0xFD is from Command & Conquer)
        } else if (cmd !== 0xFF && cmd !== 0xFD && cmd !== 0xB4 && cmd !== 0x56 && cmd !== 0xB8) { //Unknown
          if (cmd === 0) { //Next device
            device += 1;
          } else if (device === 4) { //EEprom
            this.processEeprom(pifRamStart, count);
            break;
          } else if (device < 4) { //Controllers 0-3
            if (this.processController(count, device, pifRamStart) === false) {
              break;
            }
            device += 1;
            //size of Command-Bytes + size of Answer-Bytes + 2 for the 2 size Bytes (1 is in count+=1)
            count += cmd + (this.pifUint8Array[(pifRamStart + count + 1) ^ 3] & 0x3F) + 1;
          } else {
            log("Device > 4. Device = " + device);
            break;
          }
        }
        count += 1;
      }
      this.pifUint8Array[(pifRamStart + 63) ^ 3] = 0; //Set the last bit to 0 (successful return)
    }

    processEeprom(pifRamStart, count) {
      switch (this.pifUint8Array[(pifRamStart + count + 2) ^ 3]) {
        case 0xFF:
        case 0x00:
          this.pifUint8Array[(pifRamStart + count + 3) ^ 3] = 0x00;
          this.pifUint8Array[(pifRamStart + count + 4) ^ 3] = this.eepromStatusByte;
          this.pifUint8Array[(pifRamStart + count + 5) ^ 3] = 0x00;
          break;
        case 0x04: //Read from Eeprom
          this.readEeprom(pifRamStart, count + 4, this.pifUint8Array[(pifRamStart + count + 3) ^ 3] * 8);
          break;
        case 0x05: //Write to Eeprom
          this.writeEeprom(pifRamStart, count + 4, this.pifUint8Array[(pifRamStart + count + 3) ^ 3] * 8);
          break;
      }
      return false;
    }

    binArrayToJson(buf) {
      return String.fromCharCode.apply(null, new Uint8Array(buf));
    }

    jsonToArray(str) {
      var buf, bufView, i, j, ref;
      buf = new ArrayBuffer(str.length); // 1 byte for each char
      bufView = new Uint8Array(buf);
      for (i = j = 0, ref = str.length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        bufView[i] = str.charCodeAt(i);
      }
      return buf;
    }

    loadEepromFile() {
      var e, eeprom;
      eeprom = localStorage.getItem(this.eepromName);
      if (eeprom !== null && this.eepromLoaded === false) {
        try {
          this.eeprom = new Uint8Array(this.jsonToArray(eeprom));
          if (this.eeprom.length !== 0x1000) {
            throw Error("Failed to load game save");
          }
        } catch (error) {
          e = error;
          alert("Failed to load game save");
          localStorage.removeItem(this.eepromName);
          this.eeprom = new Uint8Array(0x1000);
        }
      }
      this.eepromLoaded = true;
    }

    writeEepromFile() {
      localStorage.setItem(this.eepromName, this.binArrayToJson(this.eeprom));
    }

    // keep files stored as big-endian
    readEeprom(pifRamStart, count, offset) {
      this.loadEepromFile();
      this.pifUint8Array[(pifRamStart + count) ^ 3] = this.eeprom[offset];
      this.pifUint8Array[(pifRamStart + count + 1) ^ 3] = this.eeprom[offset + 1];
      this.pifUint8Array[(pifRamStart + count + 2) ^ 3] = this.eeprom[offset + 2];
      this.pifUint8Array[(pifRamStart + count + 3) ^ 3] = this.eeprom[offset + 3];
      this.pifUint8Array[(pifRamStart + count + 4) ^ 3] = this.eeprom[offset + 4];
      this.pifUint8Array[(pifRamStart + count + 5) ^ 3] = this.eeprom[offset + 5];
      this.pifUint8Array[(pifRamStart + count + 6) ^ 3] = this.eeprom[offset + 6];
      this.pifUint8Array[(pifRamStart + count + 7) ^ 3] = this.eeprom[offset + 7];
    }

    writeEeprom(pifRamStart, count, offset) {
      this.loadEepromFile();
      this.eeprom[offset] = this.pifUint8Array[(pifRamStart + count) ^ 3];
      this.eeprom[offset + 1] = this.pifUint8Array[(pifRamStart + count + 1) ^ 3];
      this.eeprom[offset + 2] = this.pifUint8Array[(pifRamStart + count + 2) ^ 3];
      this.eeprom[offset + 3] = this.pifUint8Array[(pifRamStart + count + 3) ^ 3];
      this.eeprom[offset + 4] = this.pifUint8Array[(pifRamStart + count + 4) ^ 3];
      this.eeprom[offset + 5] = this.pifUint8Array[(pifRamStart + count + 5) ^ 3];
      this.eeprom[offset + 6] = this.pifUint8Array[(pifRamStart + count + 6) ^ 3];
      this.eeprom[offset + 7] = this.pifUint8Array[(pifRamStart + count + 7) ^ 3];
      this.writeEepromFile();
    }

    processController(count, device, pifRamStart) {
      var buttons, cmd;
      if (this.controlsPresent[device] === false) {
        this.pifUint8Array[(pifRamStart + count + 1) ^ 3] |= 0x80;
        this.pifUint8Array[(pifRamStart + count + 3) ^ 3] = 0;
        this.pifUint8Array[(pifRamStart + count + 4) ^ 3] = 0;
        this.pifUint8Array[(pifRamStart + count + 5) ^ 3] = 0;
        return true;
      }
      buttons = void 0;
      cmd = this.pifUint8Array[(pifRamStart + count + 2) ^ 3];
      switch (cmd) {
        //0xFF could be something like Reset Controller and return the status
        case 0xFF:
        case 0: //0x00 return the status
          this.pifUint8Array[(pifRamStart + count + 3) ^ 3] = 5; //For Adaptoid
          this.pifUint8Array[(pifRamStart + count + 4) ^ 3] = 0; //For Adaptoid
          //todo: mempak, sram, eeprom save save & rumblepak
          this.pifUint8Array[(pifRamStart + count + 5) ^ 3] = 0; //no mempak (For Adaptoid)
          break;
        case 1:
          buttons = this.readControllerData();
          this.pifUint8Array[(pifRamStart + count + 3) ^ 3] = buttons >> 24;
          this.pifUint8Array[(pifRamStart + count + 4) ^ 3] = buttons >> 16;
          this.pifUint8Array[(pifRamStart + count + 5) ^ 3] = buttons >> 8;
          this.pifUint8Array[(pifRamStart + count + 6) ^ 3] = buttons;
          break;
        case 2:
        case 3:
          log("todo: read/write controller pak");
          return false;
        default:
          log("unknown controller command: " + cmd);
      }
      return true;
    }

    readControllerData() {
      return this.g1964buttons;
    }

  };

  //hack global space until we export classes properly
  //node.js uses exports; browser uses this (window)
  root = typeof exports !== "undefined" && exports !== null ? exports : self;

  root.C1964jsPifLE = C1964jsPifLE;

}).call(this);
