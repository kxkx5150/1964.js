// Generated by CoffeeScript 2.5.1
(function() {
  /*1964js - JavaScript/HTML5 port of 1964 - N64 emulator
  Copyright (C) 2012 Joel Middendorf

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.*/
  
  // Project started March 4, 2012
  // For fastest results, use Chrome.

  // NOTES:
  // fixed bgtz bgtzl
  // improved ldc1,sdc1 ..could still be bugged.

  // possible BUGS in original 1964cpp?:
  // - JAL & JALR instr_index: upper 4 bits are from the pc's delay slot, not the current pc!
  // write to si_status reg was clearing MI_INTR_SI unconditionally! this was
  // causing sinus, plasma, hardcoded, mandelbrot zoomer, lightforce, and other demos to not work in 1964js.
  // - mtc0 index should be cp0[index] & 0x80000000 | r[n] & 0x3f?
  // - aValue is not applicable in jalr (dynabranch.h)
  // - shift amounts of 0 truncate 64bit registers to 32bit. This is a possible bug in the original 1964cpp.
  // 1964 Masked loads and store addresses to make them aligned in load/store opcodes.
  // Check_SW, setting DPC_END_REG equal to DPC_START_REG is risky initialization:
  // setInt32(spReg1Uint8Array, SP_STATUS_REG, SP_STATUS_HALT, spReg1Uint32Array);
  // 1964cpp's init sets SP_STATUS_REG to SP_STATUS_HALT but then clears it in RCP_Reset() !
  // call to tlbwi masked index with &31 .. (seems wrong)

  // Use a typed-array but access it a byte at a time for endian-safety.
  // Do not use the DataView .getInt16, getInt32, etc functions. These will ensure endian
  // safety but they are a lot slower than accessing an Int8Array() by its index with the [] notation.

  //TODO:
  // Long-term: more opcodes/timers/WinGL
  // Short-term:
  //  - sdr, sdl, etc..
  // AI_LEN_REG so SP Goldeneye Crap demo can work.
  // dmult, and ddiv don't handle negative correctly. BigInt.js
  // - Where are dadd and dmult?

  // - Should handle exceptions in delay slots by catching thrown exceptions.

  //Convention:
  // When loading/storing registers back into n64 memory,
  // do so byte-by-byte since typed-arrays aren't endian-safe.
  // It's easier to get your head around and it's plenty fast.
  // The hope is that the compiler will optimimize the pattern
  // with a swap or bswap.

  // Take care when using @helpers.RS(i) + "+" + @helpers.soffset_imm(i). I used to explicitly wrap it in ()>>0 to convert to int, but
  // everywhere it is currently used implicitly uses it as a 32bit int. In a few cases, if it is assigned to a float, it could be larger than 32bits.

  /*jslint bitwise: true, evil: true, undef: false, todo: true, browser: true, devel: true*/
  /*globals Int32Array, ArrayBuffer, Float32Array, C1964jsMemory, C1964jsInterrupts, C1964jsConstants, C1964jsPif, C1964jsDma, Float64Array, C1964jsWebGL, cancelAnimFrame, C1964jsHelpers, dec2hex, Uint8Array, Uint16Array, requestAnimFrame*/
  "use strict";
  var C1964jsEmulator, consts, offset, root;

  consts = new C1964jsConstants();

  offset = void 0;

  C1964jsEmulator = class C1964jsEmulator {
    callBind(fn, me) {
      return function() {
        return fn.call(me);
      };
    }

    constructor(userSettings, buffer) {
      var bootCode, i, j, k, l, x, y;
      this.runLoop = this.runLoop.bind(this);
      //make way for another 1964 instance. cleanup old scripts written to the page.
      this.stopEmulatorAndCleanup = this.stopEmulatorAndCleanup.bind(this);
      //@runLoop = @callBind @runLoop, this
      i = void 0;
      this.settings = userSettings;
      this.request = undefined;
      this.debug = false;
      this.cp0 = new Int32Array(32);
      this.cp1Buffer = new ArrayBuffer(32 * 4); // *4 because ArrayBuffers are in bytes
      this.cp1_i = new Int32Array(this.cp1Buffer);
      this.cp1_f = new Float32Array(this.cp1Buffer);
      this.cp1_f64 = new Float64Array(this.cp1Buffer);
      this.cp1Con = new Int32Array(32);
      this.LLbit = 0;
      //var docElement, errorElement, g, s, interval, stopCompiling, offset, programCounter, romLength, redrawDebug=0;
      this.terminate = false;
      this.NUM_CHANNELS = 1;
      this.NUM_SAMPLES = 40000;
      this.SAMPLE_RATE = 40000;
      this.useByteCompatibilityMode = false; //if true, slower, but works for any endian system because memory loads and stores are accessed one byte at a time. Overrides endian check if true.
      this.isLittleEndian = 0; // determined by the system. If is little endian, memory is reordered to little-endian to optimize loads and stores.
      this.isBigEndian = 0;
      this.interval = 0;
      this.m = new Int32Array(1);
      this.m[0] = -625000; //which is magic_number / (interval+1)
      this.forceRepaint = false; //presumably origin reg doesn't change because not double or triple-buffered (single-buffered)
      //main run loop
      this.doOnce = 0;
      this.kk = 0;
      this.TV_SYSTEM_NTSC = 1;
      this.TV_SYSTEM_PAL = 0;
      this.currentHack = 0;
      this.kfi = 3200000;
      this.cnt = 0;
      // temps start at r[35]
      this.gpr = new ArrayBuffer(35 * 4 + 4 * 5); // 32GPRs, 1 dummy location to catch attempts to write to r0, and 1 lo and 1 hi, 4 temporary vars.
      this.r = new Int32Array(this.gpr);
      this.r[0] = 0;
      this.r[1] = 0;
      this.r[2] = 0xd1731be9;
      this.r[3] = 0xd1731be9;
      this.r[4] = 0x001be9;
      this.r[5] = 0xf45231e5;
      this.r[6] = 0xa4001f0c;
      this.r[7] = 0xa4001f08;
      this.r[8] = 0x070;
      this.r[9] = 0;
      this.r[10] = 0x040;
      this.r[11] = 0xA4000040;
      this.r[12] = 0xd1330bc3;
      this.r[13] = 0xd1330bc3;
      this.r[14] = 0x25613a26;
      this.r[15] = 0x2ea04317;
      this.r[16] = 0;
      this.r[17] = 0;
      this.r[18] = 0;
      this.r[19] = 0;
      this.r[20] = 0;
      this.r[21] = 0;
      this.r[22] = 0;
      this.r[23] = 0x06;
      this.r[24] = 0;
      this.r[25] = 0xd73f2993;
      this.r[26] = 0;
      this.r[27] = 0;
      this.r[28] = 0;
      this.r[29] = 0xa4001ff0;
      this.r[30] = 0;
      this.r[31] = 0xa4001554;
      this.r[32] = 0;
      this.r[33] = 0;
      this.r[34] = 0;
      this.gprh = new ArrayBuffer(35 * 4);
      this.h = new Int32Array(this.gprh);
      this.fnLut = [];
      this.fn = void 0;
      this.log = function(message) {
        return console.log(message);
      };
      this.endianTest();
      //hook-up system objects
      if (this.useByteCompatibilityMode === true) {
        /**
         * @const
         */
        this.memory = new C1964jsMemory(this);
        this.interrupts = new C1964jsInterrupts(this, this.cp0);
        this.pif = new C1964jsPif(this.memory.pifUint8Array);
        this.dma = new C1964jsDma(this.memory, this.interrupts, this.pif);
      } else if (this.isLittleEndian === 1) {
        /**
         * @const
         */
        this.memory = new C1964jsMemoryLE(this);
        this.interrupts = new C1964jsInterrupts(this, this.cp0);
        this.pif = new C1964jsPifLE(this.memory.pifUint8Array);
        this.dma = new C1964jsDmaLE(this.memory, this.interrupts, this.pif);
      } else {
        /**
         * @const
         */
        this.memory = new C1964jsMemory(this);
        this.interrupts = new C1964jsInterrupts(this, this.cp0);
        this.pif = new C1964jsPif(this.memory.pifUint8Array);
        this.dma = new C1964jsDma(this.memory, this.interrupts, this.pif);
      }
      this.memory.initRegions();
      this.webGL = new C1964jsWebGL(this, userSettings.wireframe);
      this.helpers = new C1964jsHelpers(this, this.isLittleEndian);
      this.initTLB();
      this.initOpcodeMap();
      //todo: verity that r[8] is 0x070
      cancelAnimFrame(this.request);
      this.currentHack = 0;
      this.dma.startTime = 0;
      this.kfi = 512;
      this.doOnce = 0;
      this.interval = 0;
      this.m[0] = -125000; //which is magic_number / (interval+1)
      this.flushDynaCache();
      this.showFB = true;
      this.webGL.hide3D();
      //canvas
      this.ctx = document.getElementById("Canvas").getContext("2d");
      /**
       * @const
       */
      this.ImDat = this.ctx.createImageData(320, 240);
      this.stopCompiling = false;
      this.docElement = document.getElementById("screen");
      this.errorElement = document.getElementById("error");
      this.p = new Int32Array(1);
      //set ram size
      this.currentRdramSize = this.getRdramSize();
      this.crc1 = 0;
      this.crc2 = 0;
      this.romName = new Uint8Array(20);
      //runTest();

      // function init()
      //   r[32] = LO for mult
      //   r[33] = HI for mult
      //   r[34] = write-only. to protect r0, write here.
      this.memory.rom = new Uint8Array(buffer);
      //fill alpha
      i = 3;
      y = 0;
      while (y < 240) {
        x = 0;
        while (x < 320) {
          this.ImDat.data[i] = 255;
          i += 4;
          x += 1;
        }
        y += 1;
      }
      if (this.useByteCompatibilityMode === true) {
        this.byteSwap(this.memory.rom);
      } else if (this.isLittleEndian === 1) {
        this.byteSwapLE(this.memory.rom);
      } else {
        this.byteSwap(this.memory.rom);
      }
      
      //rom = new Uint8Array(buffer);
      this.memory.romUint8Array = this.memory.rom;
      if (this.useByteCompatibilityMode === false) {
        this.memory.romUint16Array = new Uint16Array(buffer);
        this.memory.romUint32Array = new Uint32Array(buffer);
      }
      //copy first 4096 bytes to sp_dmem and run from there.
      k = 0;
      while (k < 0x1000) {
        this.memory.spMemUint8Array[k] = this.memory.rom[k];
        k += 1;
      }
      if (this.isLittleEndian === 1 && this.useByteCompatibilityMode === false) {
        this.r[20] = this.getTVSystem(this.memory.romUint8Array[0x3D]);
      } else {
        this.r[20] = this.getTVSystem(this.memory.romUint8Array[0x3E]);
      }
      bootCode = this.getBootCode();
      this.r[22] = bootCode.cic;
      this.cp0[consts.STATUS] = 0x70400004;
      this.cp0[consts.RANDOM] = 0x0000001f;
      this.cp0[consts.CONFIG] = 0x0006e463;
      this.cp0[consts.PREVID] = 0x00000b00;
      this.cp1Con[0] = 0x00000511;
      this.p[0] = 0xA4000040; //set programCounter to start of SP_MEM and after the 64 byte ROM header.
      this.memory.setInt32(this.memory.miUint8Array, consts.MI_VERSION_REG, 0x01010101, this.memory.miUint32Array);
      this.memory.setInt32(this.memory.riUint8Array, consts.RI_CONFIG_REG, 0x00000001, this.memory.riUint32Array);
      this.memory.setInt32(this.memory.viUint8Array, consts.VI_INTR_REG, 0x000003FF, this.memory.viUint32Array);
      this.memory.setInt32(this.memory.viUint8Array, consts.VI_V_SYNC_REG, 0x000000D1, this.memory.viUint32Array);
      this.memory.setInt32(this.memory.viUint8Array, consts.VI_H_SYNC_REG, 0x000D2047, this.memory.viUint32Array);
      
      // rom header
      //copy rom name
      if (this.isLittleEndian === 1 && this.useByteCompatibilityMode === false) {
        for (i = j = 0; j < 20; i = ++j) {
          this.romName[i] = this.memory.rom[(32 + i) ^ 3];
        }
      } else {
        for (i = l = 0; l < 20; i = ++l) {
          this.romName[i] = this.memory.rom[32 + i];
        }
      }
      //copy crc1
      this.crc1 = this.memory.getUint32(this.memory.rom, 16);
      //copy crc2
      this.crc2 = this.memory.getUint32(this.memory.rom, 20);
      this.pif.eepromName = this.pif.binArrayToJson(this.romName) + "-" + dec2hex(this.crc1) + dec2hex(this.crc2) + ".eep";
      console.log("EEPRom name = " + this.pif.eepromName);
      this.memory.setInt32(this.memory.u8, bootCode.rdramSizeAddress, this.currentRdramSize, this.memory.u32);
      //this.memory.setInt32(this.memory.spReg1Uint8Array, SP_STATUS_REG, SP_STATUS_HALT, this.memory.spReg1Uint32Array);
      //1964cpp sets this then clears it in RCP_Reset() !

      //set hi vals
      i = 0;
      while (i < 35) {
        this.h[i] = this.r[i] >> 31;
        i += 1;
      }
      return;
    }

    getRdramSize() {
      return 0x800000; //4MB RDRAM + 4MB Expansion = 8MB
    }

    
      //swap to 0x80371240
    byteSwap(rom) {
      var fmt, k, temp;
      k = void 0;
      fmt = void 0;
      temp = void 0;
      console.log("byte swapping...");
      fmt = this.memory.getUint32(rom, 0);
      switch (fmt >>> 0) {
        case 0x37804012:
          if ((rom.byteLength % 2) !== 0) {
            alert("help: support odd byte lengths for this swap");
          }
          k = 0;
          while (k < rom.byteLength) {
            temp = rom[k];
            rom[k] = rom[k + 1];
            rom[k + 1] = temp;
            k += 2;
          }
          break;
        case 0x80371240:
          break;
        default:
          this.log("Unhandled byte order: 0x" + dec2hex(fmt));
      }
      console.log("swap done");
    }

    byteSwapLE(rom) {
      var fmt, k, temp, temp1, temp2;
      k = void 0;
      fmt = void 0;
      temp = void 0;
      temp2 = void 0;
      console.log("byte swapping...");
      fmt = this.memory.getUint32(rom, 0);
      switch (fmt >>> 0) {
        case 0x12408037: //37804012 in memory
          if ((rom.byteLength % 2) !== 0) {
            //needs to be 0x40123780
            alert("help: support odd byte lengths for this swap");
          }
          if ((rom.byteLength % 4) !== 0) {
            alert("help: support odd byte lengths for this swap");
          }
          k = 0;
          while (k < rom.byteLength) {
            temp = rom[k];
            temp1 = rom[k + 1];
            rom[k] = rom[k + 2];
            rom[k + 1] = rom[k + 3];
            rom[k + 2] = temp;
            rom[k + 3] = temp1;
            k += 4;
          }
          break;
        case 0x40123780:
          k = 0;
          while (k < rom.byteLength) {
            temp = rom[k + 3];
            rom[k + 3] = rom[k];
            rom[k] = temp;
            temp = rom[k + 1];
            rom[k + 1] = rom[k + 2];
            rom[k + 2] = temp;
            k += 4;
          }
          break;
        default:
          this.log("Unhandled byte order: 0x" + dec2hex(fmt));
      }
      console.log("swap done");
    }

    endianTest() {
      var ii, iiSetView, iiView;
      ii = new ArrayBuffer(2);
      iiSetView = new Uint8Array(ii);
      iiView = new Uint16Array(ii);
      iiSetView[0] = 0xff;
      iiSetView[1] = 0x11;
      if (iiView[0] === 0x11FF) {
        this.log("You are on a little-endian system");
        this.isLittleEndian = 1;
        this.isBigEndian = 0;
      } else {
        this.log("You are on a big-endian system");
        this.isLittleEndian = 0;
        this.isBigEndian = 1;
      }
    }

    repaintLE(ctx, ImDat) {
      var i, k, out, y;
      out = void 0;
      i = 0;
      y = void 0;
      if (!this.showFB) {
        return;
      }
      //get origin
      k = this.memory.getInt32(this.memory.viUint8Array, consts.VI_ORIGIN_REG, this.memory.viUint32Array) & 0x00FFFFFF;
      out = ImDat.data;
      //endian-safe blit: rgba5551
      y = -240 * 320;
      const u8 = this.memory.u8;
      while (y !== 0) {
        out[i] = u8[k + 3] & 0xF8;
        out[i + 1] = ((u8[k + 3] << 5) | (u8[k + 2] >>> 3)) & 0xF8;
        out[i + 2] = u8[k + 2] << 2 & 0xF8;
        out[i + 4] = u8[k + 1] & 0xF8;
        out[i + 5] = ((u8[k + 1] << 5) | (u8[k] >>> 3)) & 0xF8;
        out[i + 6] = u8[k] << 2 & 0xF8;
        k += 4;
        i += 8;
        y += 2;
      }
      ctx.putImageData(ImDat, 0, 0);
    }

    repaint(ctx, ImDat) {
      var i, k, out, y;
      out = void 0;
      i = 0;
      y = void 0;
      if (!this.showFB) {
        return;
      }
      //get origin
      k = this.memory.getInt32(this.memory.viUint8Array, consts.VI_ORIGIN_REG) & 0x00FFFFFF;
      out = ImDat.data;
      //endian-safe blit: rgba5551
      y = -240 * 320;
      const u8 = this.memory.u8;
      while (y !== 0) {
        out[i] = u8[k] & 0xF8;
        out[i + 1] = ((u8[k] << 5) | (u8[k + 1] >>> 3)) & 0xF8;
        out[i + 2] = u8[k + 1] << 2 & 0xF8;
        out[i + 4] = u8[k + 2] & 0xF8;
        out[i + 5] = ((u8[k + 2] << 5) | (u8[k + 3] >>> 3)) & 0xF8;
        out[i + 6] = u8[k + 3] << 2 & 0xF8;
        k += 4;
        i += 8;
        y += 2;
      }
      ctx.putImageData(ImDat, 0, 0);
    }

    initTLB() {
      var dTLBIndex, i, iTLBIndex, lastDTLBIndex, lastITLBIndex;
      this.tlb = new Array(32);
      i = 0;
      while (i < 32) {
        this.tlb[i] = {
          valid: false,
          entryHi: new Int32Array(1),
          entryLo1: new Int32Array(1),
          entryLo0: new Int32Array(1),
          pageMask: new Int32Array(1),
          loCompare: new Int32Array(1),
          myHiMask: new Int32Array(1)
        };
        i += 1;
      }
      iTLBIndex = [0, 0];
      dTLBIndex = [0, 0, 0];
      lastITLBIndex = 0;
      lastDTLBIndex = 0;
      this.memory.initts();
    }

    runLoop() {
      var aa, fn, pc;
      //setTimeout to be a good citizen..don't allow for the cpu to be pegged at 100%.
      //8ms idle time will be 50% cpu max if a 60FPS game is slow.
      if (this.startTime === void 0) {
        this.startTime = Date.now();
      }
      //@request = requestAnimFrame(@runLoop)  if @terminate is false
      if (this.terminate === true) {
        clearInterval(this.mySetInterval);
        return;
      }
      const m = this.m;
      const r = this.r;
      const h = this.h;
      const p = this.p;
      fn = this.fn;
      aa = 10000;
      while (this.terminate === false && aa !== 0) {
        aa--;
        //@interrupts.checkInterrupts()
        if (m[0] >= 0) {
          this.interval += 1;
          //@m[0] = -125000 # which is -625000 / (interval+1)
          m[0] = -156250; // which is -625000 / (interval+1) / 2
          pc = p[0];
          this.interrupts.processException(p[0]);
          if (this.interval === 4) {
            this.interval = 0;
            this.repaintWrapper();
            this.cp0[consts.COUNT] += 625000 * 2; //todo: set count to count + @m*2 when count is requested in code
            this.interrupts.triggerCompareInterrupt(0, false);
            this.interrupts.triggerVIInterrupt(0, false); //if ((@memory.getInt32(@memory.miUint8Array, consts.MI_INTR_REG, core.memory.miUint32Array) & consts.MI_INTR_VI) isnt 0)
          } else if (this.interval === 2) {
            this.interrupts.checkInterrupts();
            if (pc !== p[0]) {
              pc = p[0] >>> 2;
              fn = this.fnLut[pc];
            }
            break;
          }
          if (pc !== p[0]) {
            pc = p[0] >>> 2;
            fn = this.fnLut[pc];
          }
        } else {
          fn = this.run(fn, r, h);
        }
      }
      this.fn = fn;
      return this;
    }

    run(fn, r, h) {
      const m = this.m;
      const mem = this.memory;
      const t = this;
      while (m[0] < 0) {
        if (typeof fn === 'function') {
          fn = fn(r, h, mem, t);
        } else {
          fn = this.decompileBlock(t.p[0]);
        }
      }
      return fn;
    }

    repaintWrapper() {
      if (this.isLittleEndian === 1 && this.useByteCompatibilityMode === false) {
        this.repaintLE(this.ctx, this.ImDat);
      } else {
        this.repaint(this.ctx, this.ImDat);
      }
    }

    asyncFastLoop() {
      this.myFastInterval = setInterval(() => {
        this.runLoop();
      }, 0.0);
    }

    startEmulator() {
      self.requestAnimationFrame = self.requestAnimationFrame || self.mozRequestAnimationFrame || self.webkitRequestAnimationFrame || self.msRequestAnimationFrame || f(() => {
        return setTimeout(f, 0.0);
      });
      this.terminate = false;
      this.log("startEmulator");
      this.settings.rateWithDelta = 1000.0 / 60.0;
      MainLoop.setUpdate().setDraw(i1964js.runLoop).setEnd().start();
    }

    stopEmulatorAndCleanup() {
      this.terminate = true;
      clearInterval(this.myFastInterval);
      this.m[0] = 0;
      this.log("stopEmulatorAndCleanup");
      MainLoop.stop();
      this.stopCompiling = true;
      this.flushDynaCache();
    }

    onSpeedLimitChanged() {
      var speedlimit;
      speedlimit = document.getElementById("speedlimit");
      clearInterval(this.myFastInterval);
      if (speedlimit === null || speedlimit.checked === false) {
        MainLoop.stop();
        this.asyncFastLoop();
      } else {
        this.startEmulator();
      }
    }

    //clearInterval(interval);
    getFnName(pc) {
      return "_" + (pc >>> 2);
    }

    decompileBlock(pc) {
      var fnName, g, instruction, s, string;
      offset = 0;
      g = void 0;
      s = void 0;
      this.cnt = 0;
      instruction = void 0;
      string = void 0;
      fnName = "_" + (pc >>> 2);
      //Syntax: function(register, hiRegister, this.memory, this)
      string = fnName + "=(r,h,m,t)=>{";
      while (!this.stopCompiling) {
        instruction = this.memory.lw(pc + offset);
        this.cnt += 1;
        string += this.CPU_instruction(instruction);
        offset += 4;
        if (offset > 10000) {
          this.terminate = true;
          throw Error("too many instructions! bailing.");
        }
      }
      this.stopCompiling = false;
      //close out the function
      string += "t.m[0]+=" + this.cnt;
      string += ";t.p[0]=" + ((pc + offset) | 0);
      string += ";return self." + this.getFnName((pc + offset) | 0) + "}";
      g = document.createElement("script");
      if (!this.s) {
        this.s = document.getElementsByTagName("script")[0];
      }
      this.kk += 1;
      this.s.parentNode.insertBefore(g, this.s);
      g.text = string;
      return this.fnLut[pc >>> 2] = self[fnName];
    }

    r4300i_add(i) {
      return this.helpers.sLogic(i, "+");
    }

    r4300i_addu(i) {
      return this.helpers.sLogic(i, "+");
    }

    r4300i_sub(i) {
      return this.helpers.sLogic(i, "-");
    }

    r4300i_subu(i) {
      return this.helpers.sLogic(i, "-");
    }

    r4300i_or(i) {
      return this.helpers.dLogic(i, "|");
    }

    r4300i_xor(i) {
      return this.helpers.dLogic(i, "^");
    }

    r4300i_nor(i) {
      return this.helpers.tRD(i) + "=~(" + this.helpers.RS(i) + "|" + this.helpers.RT(i) + ");" + this.helpers.tRDH(i) + "=~(" + this.helpers.RSH(i) + "|" + this.helpers.RTH(i) + ");";
    }

    r4300i_and(i) {
      return this.helpers.dLogic(i, "&");
    }

    r4300i_lui(i) {
      var temp, tempHi;
      temp = (i & 0x0000ffff) << 16;
      tempHi = temp >> 31;
      return this.helpers.tRT(i) + "=" + temp + ";" + this.helpers.tRTH(i) + "=" + tempHi + ";";
    }

    r4300i_lw(i) {
      return this.helpers.virtualToPhysical(this.helpers.RS(i) + "+" + this.helpers.soffset_imm(i)) + this.helpers.tRT(i) + "=m.LW[r[36]>>>16](r[36]);" + this.helpers.tRTH(i) + "=" + this.helpers.RT(i) + ">>31;";
    }

    r4300i_lwu(i) {
      return this.helpers.virtualToPhysical(this.helpers.RS(i) + "+" + this.helpers.soffset_imm(i)) + this.helpers.tRT(i) + "=m.LW[r[36]>>>16](r[36]);" + this.helpers.tRTH(i) + "=0;";
    }

    r4300i_sw(i, isDelaySlot) {
      var a, string;
      a = void 0;
      //    string = "m.sw(" + @helpers.RT(i) + ";" + @helpers.RS(i) + "+" + @helpers.soffset_imm(i)
      string = this.helpers.virtualToPhysical("" + this.helpers.RS(i) + "+" + this.helpers.soffset_imm(i) + "") + "m.SW[r[36]>>>16](" + this.helpers.RT(i) + ",r[36]";
      //So we can process exceptions
      if (isDelaySlot === true) {
        a = (this.p[0] + offset + 4) | 0;
        string += "," + a + ",true);";
      } else {
        a = (this.p[0] + offset) | 0;
        string += "," + a + ");";
      }
      return string;
    }

    delaySlot(i, likely) {
      var c, instruction, opcode, pc, string;
      pc = void 0;
      instruction = void 0;
      opcode = void 0;
      string = void 0;
      pc = (this.p[0] + offset + 4 + (this.helpers.soffset_imm(i) << 2)) | 0;
      instruction = this.memory.lw((this.p[0] + offset + 4) | 0);
      opcode = this.CPU_instruction(instruction, true);
      //speed hack
      if (instruction === 0 && this.helpers.soffset_imm(i) === -1) {
        string = opcode + "t.m[0]=0;t.p[0]=" + pc + ";return self." + this.getFnName(pc) + "}";
      } else {
        c = this.cnt + 1;
        string = opcode + "t.m[0]+=" + c + ";t.p[0]=" + pc + ";return self." + this.getFnName(pc) + "}";
      }
      
      //if likely and if branch not taken, skip delay slot
      if (likely === false) {
        string += opcode + "t.m[0]++;";
      }
      offset += 4;
      return string;
    }

    r4300i_bne(i) {
      this.stopCompiling = true;
      return "if(" + this.helpers.RS(i) + "-" + this.helpers.RT(i) + "|" + this.helpers.RSH(i) + "-" + this.helpers.RTH(i) + "){" + this.delaySlot(i, false);
    }

    r4300i_bnel(i) {
      this.stopCompiling = true;
      return "if(" + this.helpers.RS(i) + "-" + this.helpers.RT(i) + "|" + this.helpers.RSH(i) + "-" + this.helpers.RTH(i) + "){" + this.delaySlot(i, true);
    }

    r4300i_beq(i) {
      this.stopCompiling = true;
      if (this.helpers.rs(i) === this.helpers.rt(i)) {
        return "{" + this.delaySlot(i, false);
      } else {
        return "if(" + this.helpers.RS(i) + "===" + this.helpers.RT(i) + "&" + this.helpers.RSH(i) + "===" + this.helpers.RTH(i) + "){" + this.delaySlot(i, false);
      }
    }

    r4300i_beql(i) {
      this.stopCompiling = true;
      if (this.helpers.rs(i) === this.helpers.rt(i)) {
        return "{" + this.delaySlot(i, true);
      } else {
        return "if(" + this.helpers.RS(i) + "===" + this.helpers.RT(i) + "&" + this.helpers.RSH(i) + "===" + this.helpers.RTH(i) + "){" + this.delaySlot(i, true);
      }
    }

    r4300i_blez(i) {
      this.stopCompiling = true;
      return "if(" + this.helpers.RSH(i) + "<0|!(" + this.helpers.RSH(i) + "|" + this.helpers.RS(i) + ")){" + this.delaySlot(i, false);
    }

    r4300i_blezl(i) {
      this.stopCompiling = true;
      return "if(" + this.helpers.RSH(i) + "<0|!(" + this.helpers.RSH(i) + "|" + this.helpers.RS(i) + ")){" + this.delaySlot(i, true);
    }

    r4300i_bgez(i) {
      this.stopCompiling = true;
      return "if(" + this.helpers.RSH(i) + ">=0){" + this.delaySlot(i, false);
    }

    r4300i_bgezl(i) {
      this.stopCompiling = true;
      return "if(" + this.helpers.RSH(i) + ">=0){" + this.delaySlot(i, true);
    }

    r4300i_bgtz(i) {
      this.stopCompiling = true;
      return "if(" + this.helpers.RSH(i) + ">=0&(" + this.helpers.RSH(i) + "|" + this.helpers.RS(i) + ")!==0){" + this.delaySlot(i, false);
    }

    r4300i_bgtzl(i) {
      this.stopCompiling = true;
      return "if(" + this.helpers.RSH(i) + ">=0&(" + this.helpers.RSH(i) + "|" + this.helpers.RS(i) + ")!==0){" + this.delaySlot(i, true);
    }

    r4300i_bltzl(i) {
      this.stopCompiling = true;
      return "if(" + this.helpers.RSH(i) + "<0){" + this.delaySlot(i, true);
    }

    r4300i_bgezal(i) {
      var link;
      this.stopCompiling = true;
      link = (this.p[0] + offset + 8) >> 0;
      return "if(" + this.helpers.RSH(i) + ">=0){r[31]=" + link + ";" + "h[31]=" + (link >> 31) + ";" + this.delaySlot(i, false);
    }

    r4300i_bgezall(i) {
      var link;
      this.stopCompiling = true;
      link = (this.p[0] + offset + 8) >> 0;
      return "if(" + this.helpers.RSH(i) + ">=0){r[31]=" + link + ";" + "h[31]=" + (link >> 31) + ";" + this.delaySlot(i, true);
    }

    r4300i_bltz(i) {
      this.stopCompiling = true;
      return "if(" + this.helpers.RSH(i) + "<0){" + this.delaySlot(i, false);
    }

    r4300i_COP1_bc1f(i) {
      this.stopCompiling = true;
      return "if(!(t.cp1Con[31]&0x800000)){" + this.delaySlot(i, false);
    }

    r4300i_COP1_bc1t(i) {
      this.stopCompiling = true;
      return "if(t.cp1Con[31]&0x800000){" + this.delaySlot(i, false);
    }

    r4300i_COP1_bc1tl(i) {
      this.stopCompiling = true;
      return "if(t.cp1Con[31]&0x800000){" + this.delaySlot(i, true);
    }

    r4300i_COP1_bc1fl(i) {
      this.stopCompiling = true;
      return "if(!(t.cp1Con[31]&0x800000)){" + this.delaySlot(i, true);
    }

    r4300i_j(i) {
      var instr_index, instruction, speedUp, string;
      this.stopCompiling = true;
      instruction = void 0;
      instr_index = (((this.p[0] + offset + 4) & 0xF0000000) | ((i & 0x03FFFFFF) << 2)) | 0;
      //delay slot
      instruction = this.memory.lw((this.p[0] + offset + 4) | 0);
      //speed hack
      speedUp = false;
      if (((instr_index >> 0) === (this.p[0] + offset) >> 0) && (instruction === 0)) {
        speedUp = true;
      }
      string = this.CPU_instruction(instruction, true);
      if (speedUp === true) {
        string += "t.m[0]=0";
      } else {
        string += "t.m[0]+=" + (this.cnt + 1);
      }
      return string += ";t.p[0]=" + instr_index + ";return self." + this.getFnName(instr_index) + ";";
    }

    r4300i_jal(i) {
      var instr_index, instruction, pc, string;
      this.stopCompiling = true;
      pc = void 0;
      instruction = void 0;
      instr_index = (((this.p[0] + offset + 4) & 0xF0000000) | ((i & 0x03FFFFFF) << 2)) | 0;
      //delay slot
      instruction = this.memory.lw((this.p[0] + offset + 4) | 0);
      string = this.CPU_instruction(instruction, true);
      pc = (this.p[0] + offset + 8) | 0;
      return string += "t.m[0]+=" + (this.cnt + 1) + ";t.p[0]=" + instr_index + ";r[31]=" + pc + ";h[31]=" + (pc >> 31) + ";return self." + this.getFnName(instr_index) + ";";
    }

    //should we set the programCounter after the delay slot or before it?
    r4300i_jalr(i) {
      var instruction, link, opcode, string;
      this.stopCompiling = true;
      instruction = void 0;
      opcode = void 0;
      link = void 0;
      // r[39] is a temp variable specific to vAddr for jalr
      string = "r[39]=" + this.helpers.RS(i) + ";";
      link = (this.p[0] + offset + 8) >> 0;
      string += this.helpers.tRD(i) + "=" + link + ";" + this.helpers.tRDH(i) + "=" + (link >> 31) + ";";
      //delay slot
      instruction = this.memory.lw((this.p[0] + offset + 4) | 0);
      opcode = this.CPU_instruction(instruction, true);
      string += opcode;
      string += "t.m[0]+=" + (this.cnt + 1) + ";t.p[0]=r[39];return t.fnLut[r[39]>>>2];";
      return string;
    }

    r4300i_jr(i) {
      var instruction, opcode, string;
      this.stopCompiling = true;
      instruction = void 0;
      opcode = void 0;
      // r[37] is a temp variable specific to vAddr for jr
      string = "r[37]=" + this.helpers.RS(i) + ";";
      //delay slot
      instruction = this.memory.lw((this.p[0] + offset + 4) | 0);
      opcode = this.CPU_instruction(instruction, true);
      string += opcode;
      return string += "t.m[0]+=" + (this.cnt + 1) + ";t.p[0]=r[37];return t.fnLut[r[37]>>>2];";
    }

    UNUSED(i) {
      this.log("warning: UNUSED");
      return "";
    }

    r4300i_syscall(i) {
      this.log("todo: r4300i_syscall");
      return "";
    }

    r4300i_COP0_eret(i) {
      var string;
      this.stopCompiling = true;
      string = "if((t.cp0[" + consts.STATUS + "]&" + consts.ERL + ")!==0){alert(\"error epc\");t.p[0]=t.cp0[" + consts.ERROREPC + "];";
      string += "t.cp0[" + consts.STATUS + "]&=~" + consts.ERL + "}else{t.p[0]=t.cp0[" + consts.EPC + "];t.cp0[" + consts.STATUS + "]&=~" + consts.EXL + "}";
      return string += "t.m[0]+=" + (this.cnt + 1) + ";t.LLbit=0;return t.fnLut[t.p[0]>>>2];";
    }

    r4300i_COP0_mtc0(i, isDelaySlot) {
      var delaySlot, lpc;
      delaySlot = void 0;
      lpc = void 0;
      if (isDelaySlot === true) {
        lpc = (this.p[0] + offset + 4) | 0;
        delaySlot = "true";
      } else {
        lpc = (this.p[0] + offset) | 0;
        delaySlot = "false";
      }
      return "t.helpers.inter_mtc0(r," + this.helpers.fs(i) + "," + this.helpers.rt(i) + "," + delaySlot + "," + lpc + ",t.cp0,t.interrupts);";
    }

    r4300i_sll(i) {
      if ((i & 0x001FFFFF) === 0) { // NOP
        return "";
      }
      if (this.helpers.rd(i) === this.helpers.rt(i)) {
        return this.helpers.tRD(i) + "<<=" + this.helpers.sa(i) + ";" + this.helpers.tRDH(i) + "=" + this.helpers.RD(i) + ">>31;";
      } else {
        return this.helpers.tRD(i) + "=" + this.helpers.RT(i) + "<<" + this.helpers.sa(i) + ";" + this.helpers.tRDH(i) + "=" + this.helpers.RD(i) + ">>31;";
      }
    }

    r4300i_srl(i) {
      var sa;
      sa = this.helpers.sa(i);
      if (sa > 0) {
        return this.helpers.tRD(i) + "=" + this.helpers.RT(i) + ">>>" + sa + ";" + this.helpers.tRDH(i) + "=0;";
      } else {
        //alert "ok"
        return this.helpers.tRDH(i) + "=" + this.helpers.RT(i) + ">>31;" + this.helpers.tRD(i) + "=" + this.helpers.RT(i) + ";";
      }
    }

    r4300i_ori(i) {
      if (this.helpers.rt(i) === this.helpers.rs(i)) {
        return this.helpers.tRT(i) + "|=" + this.helpers.offset_imm(i) + ";";
      } else {
        return this.helpers.tRT(i) + "=" + this.helpers.RS(i) + "|" + this.helpers.offset_imm(i) + ";" + this.helpers.tRTH(i) + "=" + this.helpers.RSH(i) + ";";
      }
    }

    r4300i_xori(i) {
      if (this.helpers.rt(i) === this.helpers.rs(i)) {
        return this.helpers.tRT(i) + "^=" + this.helpers.offset_imm(i) + ";";
      } else {
        return this.helpers.tRT(i) + "=" + this.helpers.RS(i) + "^" + this.helpers.offset_imm(i) + ";" + this.helpers.tRTH(i) + "=" + this.helpers.RSH(i) + ";";
      }
    }

    r4300i_andi(i) {
      if (this.helpers.rt(i) === this.helpers.rs(i)) {
        return this.helpers.tRT(i) + "&=" + this.helpers.offset_imm(i) + ";" + this.helpers.tRTH(i) + "=0;";
      } else {
        return this.helpers.tRT(i) + "=" + this.helpers.RS(i) + "&" + this.helpers.offset_imm(i) + ";" + this.helpers.tRTH(i) + "=0;";
      }
    }

    r4300i_addi(i) {
      if (this.helpers.rt(i) === this.helpers.rs(i)) {
        return this.helpers.tRT(i) + "+=" + this.helpers.soffset_imm(i) + ";" + this.helpers.tRTH(i) + "=" + this.helpers.RT(i) + ">>31;";
      } else {
        return this.helpers.tRT(i) + "=" + this.helpers.RS(i) + "+" + this.helpers.soffset_imm(i) + ";" + this.helpers.tRTH(i) + "=" + this.helpers.RT(i) + ">>31;";
      }
    }

    r4300i_addiu(i) {
      if (this.helpers.rt(i) === this.helpers.rs(i)) {
        return this.helpers.tRT(i) + "+=" + this.helpers.soffset_imm(i) + ";" + this.helpers.tRTH(i) + "=" + this.helpers.RT(i) + ">>31;";
      } else {
        return this.helpers.tRT(i) + "=" + this.helpers.RS(i) + "+" + this.helpers.soffset_imm(i) + ";" + this.helpers.tRTH(i) + "=" + this.helpers.RT(i) + ">>31;";
      }
    }

    r4300i_slt(i) {
      return this.helpers.tRD(i) + "=((" + this.helpers.RSH(i) + "<" + this.helpers.RTH(i) + ")|(!(" + this.helpers.RSH(i) + "-" + this.helpers.RTH(i) + ")&(" + this.helpers.uRS(i) + "<" + this.helpers.uRT(i) + ")));" + this.helpers.tRDH(i) + "=0;";
    }

    r4300i_sltu(i) {
      return this.helpers.tRD(i) + "=((" + this.helpers.uRSH(i) + "<" + this.helpers.uRTH(i) + ")|(!(" + this.helpers.uRSH(i) + "-" + this.helpers.uRTH(i) + ")&(" + this.helpers.uRS(i) + "<" + this.helpers.uRT(i) + ")));" + this.helpers.tRDH(i) + "=0;";
    }

    r4300i_slti(i) {
      var soffset_imm_hi, uoffset_imm_lo;
      uoffset_imm_lo = void 0;
      soffset_imm_hi = (this.helpers.soffset_imm(i)) >> 31;
      uoffset_imm_lo = (this.helpers.soffset_imm(i)) >>> 0;
      //space is important after the minus in "- " because soffset_imm_hi could be negative, and -- is decrement operator
      return this.helpers.tRT(i) + "=((" + this.helpers.RSH(i) + "<" + soffset_imm_hi + ")|(!(" + this.helpers.RSH(i) + "- " + soffset_imm_hi + ")&(" + this.helpers.uRS(i) + "<" + uoffset_imm_lo + ")));" + this.helpers.tRTH(i) + "=0;";
    }

    r4300i_sltiu(i) {
      var uoffset_imm_hi, uoffset_imm_lo;
      uoffset_imm_lo = void 0;
      uoffset_imm_hi = (this.helpers.soffset_imm(i) >> 31) >>> 0;
      uoffset_imm_lo = (this.helpers.soffset_imm(i)) >>> 0;
      //space is important after the minus in "- " because uoffset_imm_hi could be negative, and -- is decrement operator
      return this.helpers.tRT(i) + "=((" + this.helpers.uRSH(i) + "<" + uoffset_imm_hi + ")|(!(" + this.helpers.uRSH(i) + "- " + uoffset_imm_hi + ")&(" + this.helpers.uRS(i) + "<" + uoffset_imm_lo + ")));" + this.helpers.tRTH(i) + "=0;";
    }

    r4300i_cache(i) {
      this.log("todo: r4300i_cache");
      this.stopCompiling = true;
      return "";
    }

    r4300i_ll(i) {
      return this.helpers.setVAddr(i) + this.helpers.tRT(i) + "=m.lw((r[38])|0);" + "t.LLbit=1;";
    }

    r4300i_multu(i) {
      return "t.helpers.inter_multu(r,h," + i + ");";
    }

    r4300i_mult(i) {
      return "t.helpers.inter_mult(r,h," + i + ");";
    }

    r4300i_mflo(i) {
      return this.helpers.tRD(i) + "=r[32];" + this.helpers.tRDH(i) + "=h[32];";
    }

    r4300i_mfhi(i) {
      return this.helpers.tRD(i) + "=r[33];" + this.helpers.tRDH(i) + "=h[33];";
    }

    r4300i_mtlo(i) {
      return "r[32]=" + this.helpers.RS(i) + ";h[32]=" + this.helpers.RSH(i) + ";";
    }

    r4300i_mthi(i) {
      return "r[33]=" + this.helpers.RS(i) + ";h[33]=" + this.helpers.RSH(i) + ";";
    }

    r4300i_COP0_mfc0(i) {
      var string;
      string = "";
      switch (this.helpers.fs(i)) {
        case consts.RANDOM:
          alert("RANDOM");
          break;
        case consts.COUNT:
          break;
      }
      //string += 't.cp0[' + this.helpers.fs(i) + ']-=t.m*2;'; # should this be t.m * 2?
      return string += this.helpers.tRT(i) + "=t.cp0[" + this.helpers.fs(i) + "];" + this.helpers.tRTH(i) + "=t.cp0[" + this.helpers.fs(i) + "]>>31;";
    }

    r4300i_lb(i) {
      return this.helpers.virtualToPhysical(this.helpers.RS(i) + "+" + this.helpers.soffset_imm(i)) + this.helpers.tRT(i) + "=m.LB[r[36]>>>16](r[36])<<24>>24;" + this.helpers.tRTH(i) + "=" + this.helpers.RT(i) + ">>8;";
    }

    r4300i_lbu(i) {
      return this.helpers.virtualToPhysical(this.helpers.RS(i) + "+" + this.helpers.soffset_imm(i)) + this.helpers.tRT(i) + "=m.LB[r[36]>>>16](r[36]);" + this.helpers.tRTH(i) + "=0;";
    }

    r4300i_lh(i) {
      return this.helpers.virtualToPhysical(this.helpers.RS(i) + "+" + this.helpers.soffset_imm(i)) + this.helpers.tRT(i) + "=m.LH[r[36]>>>16](r[36])<<16>>16;" + this.helpers.tRTH(i) + "=" + this.helpers.RT(i) + ">>16;";
    }

    r4300i_lhu(i) {
      return this.helpers.virtualToPhysical(this.helpers.RS(i) + "+" + this.helpers.soffset_imm(i)) + this.helpers.tRT(i) + "=m.LH[r[36]>>>16](r[36]);" + this.helpers.tRTH(i) + "=0;";
    }

    r4300i_sb(i, isDelaySlot) {
      var a, string;
      //"m.sb(" + @helpers.RT(i) + "," + @helpers.RS(i) + "+" + @helpers.soffset_imm(i) + ");"
      //string = "a = m.virtualToPhysical(" + @helpers.RS(i) + "+" + @helpers.soffset_imm(i) + ");m.SB[a>>>16](" + @helpers.RT(i) + ",a"
      string = this.helpers.virtualToPhysical(this.helpers.RS(i) + "+" + this.helpers.soffset_imm(i)) + "m.SB[r[36]>>>16](" + this.helpers.RT(i) + ",r[36]";
      //So we can process exceptions
      if (isDelaySlot === true) {
        a = (this.p[0] + offset + 4) | 0;
        string += "," + a + ",true);";
      } else {
        a = (this.p[0] + offset) | 0;
        string += "," + a + ");";
      }
      return string;
    }

    r4300i_sh(i, isDelaySlot) {
      var a, string;
      //"m.sh(" + @helpers.RT(i) + "," + @helpers.RS(i) + "+" + @helpers.soffset_imm(i) + ");"
      string = this.helpers.virtualToPhysical(this.helpers.RS(i) + "+" + this.helpers.soffset_imm(i)) + "m.SH[r[36]>>>16](" + this.helpers.RT(i) + ",r[36]";
      //So we can process exceptions
      if (isDelaySlot === true) {
        a = (this.p[0] + offset + 4) | 0;
        string += "," + a + ",true);";
      } else {
        a = (this.p[0] + offset) | 0;
        string += "," + a + ");";
      }
      return string;
    }

    r4300i_srlv(i) {
      return this.helpers.tRD(i) + "=" + this.helpers.RT(i) + ">>>(" + this.helpers.RS(i) + "&0x1f);" + this.helpers.tRDH(i) + "=" + this.helpers.RD(i) + ">>31;";
    }

    r4300i_sllv(i) {
      return this.helpers.tRD(i) + "=" + this.helpers.RT(i) + "<<(" + this.helpers.RS(i) + "&0x1f);" + this.helpers.tRDH(i) + "=" + this.helpers.RD(i) + ">>31;";
    }

    r4300i_srav(i) {
      //optimization: r[hi] can safely right-shift rt
      //"{" + @helpers.tRD(i) + "=" + @helpers.RT(i) + ">>(" + @helpers.RS(i) + "&0x1f);" + @helpers.tRDH(i) + "=" + @helpers.RT(i) + ">>31}"
      return this.helpers.tRDH(i) + "=(" + this.helpers.tRD(i) + "=" + this.helpers.RT(i) + ">>(" + this.helpers.RS(i) + "&0x1f))>>31;";
    }

    r4300i_COP1_cfc1(i) {
      if (this.helpers.fs(i) === 0 || this.helpers.fs(i) === 31) {
        return this.helpers.tRTH(i) + "=(" + this.helpers.tRT(i) + "=t.cp1Con[" + this.helpers.fs(i) + "])>>31;";
      }
    }

    r4300i_COP1_ctc1(i) {
      if (this.helpers.fs(i) === 31) {
        //incomplete:
        return "t.cp1Con[31]=" + this.helpers.RT(i) + ";";
      }
    }

    r4300i_ld(i) {
      return this.helpers.setVAddr(i) + this.helpers.tRT(i) + "=m.lw((r[38]+4)|0);" + this.helpers.tRTH(i) + "=m.lw(r[38]);";
    }

    r4300i_lld(i) {
      return this.helpers.setVAddr(i) + this.helpers.tRT(i) + "=m.lw((r[38]+4)|0);" + this.helpers.tRTH(i) + "=m.lw(r[38]);t.LLbit=1;";
    }

    //address error exceptions in ld and sd are weird since this is split up
    //into 2 reads or writes. i guess they're fatal exceptions, so
    //doesn't matter.
    r4300i_sd(i, isDelaySlot) {
      var a, string;
      //lo
      a = void 0;
      string = this.helpers.setVAddr(i) + "m.sw(" + this.helpers.RT(i) + ",(r[38]+4)|0";
      //So we can process exceptions
      if (isDelaySlot === true) {
        a = (this.p[0] + offset + 4) | 0;
        string += "," + a + ",true);";
      } else {
        a = (this.p[0] + offset) | 0;
        string += "," + a + ");";
      }
      //hi
      string += "m.sw(" + this.helpers.RTH(i) + ",r[38]";
      //So we can process exceptions
      if (isDelaySlot === true) {
        a = (this.p[0] + offset + 4) | 0;
        string += "," + a + ",true);";
      } else {
        a = (this.p[0] + offset) | 0;
        string += "," + a + ");";
      }
      return string;
    }

    r4300i_dmultu(i) {
      return "t.helpers.inter_dmultu(r,h," + i + ");";
    }

    r4300i_dmult(i) {
      this.log("todo: r4300i_dmult");
      return "";
    }

    r4300i_dsll(i) {
      var string;
      string = "{var temp=" + this.helpers.RT(i) + ">>>" + (32 - this.helpers.sa(i)) + ";";
      string += this.helpers.tRDH(i) + "=" + this.helpers.RTH(i) + "<<" + this.helpers.sa(i) + ";" + this.helpers.tRD(i) + "=" + this.helpers.RT(i) + "<<" + this.helpers.sa(i) + ";";
      return string += this.helpers.tRDH(i) + "|=temp;}";
    }

    r4300i_dsrl(i) {
      var string;
      string = "{var temp=" + this.helpers.RTH(i) + "<<" + (32 - this.helpers.sa(i)) + ";";
      string += this.helpers.tRDH(i) + "=" + this.helpers.RTH(i) + ">>>" + this.helpers.sa(i) + ";" + this.helpers.tRD(i) + "=" + this.helpers.RT(i) + ">>>" + this.helpers.sa(i) + ";";
      return string += this.helpers.tRD(i) + "|=temp;}";
    }

    r4300i_dsra(i) {
      var string;
      string = "{var temp=" + this.helpers.RTH(i) + "<<" + (32 - this.helpers.sa(i)) + ";";
      string += this.helpers.tRDH(i) + "=" + this.helpers.RTH(i) + ">>" + this.helpers.sa(i) + ";" + this.helpers.tRD(i) + "=" + this.helpers.RT(i) + ">>>" + this.helpers.sa(i) + ";";
      return string += this.helpers.tRD(i) + "|=temp;}";
    }

    r4300i_dsllv(i) {
      var string;
      this.log("todo: fix r4300i_dsllv");
      string = "{var temp=" + this.helpers.RT(i) + ">>>(64-" + this.helpers.RS(i) + ");";
      string += this.helpers.tRDH(i) + "=" + this.helpers.RTH(i) + "<<" + this.helpers.RS(i) + ";" + this.helpers.tRD(i) + "=" + this.helpers.RT(i) + "<<" + this.helpers.RS(i) + ";";
      return string += this.helpers.tRDH(i) + "|=temp;}";
    }

    r4300i_dsrlv(i) {
      var string;
      this.log("todo: fix r4300i_dsrlv");
      string = "{var temp=" + this.helpers.RTH(i) + "<<(64-" + this.helpers.RS(i) + ");";
      string += this.helpers.tRDH(i) + "=" + this.helpers.RTH(i) + ">>>" + this.helpers.RS(i) + ";" + this.helpers.tRD(i) + "=" + this.helpers.RT(i) + ">>>" + this.helpers.RS(i) + ";";
      return string += this.helpers.tRD(i) + "|=temp;}";
    }

    r4300i_dsrav(i) {
      var string;
      this.log("todo: fix r4300i_dsrav");
      string = "{var temp=" + this.helpers.RTH(i) + "<<(64-" + this.helpers.RS(i) + ");";
      string += this.helpers.tRDH(i) + "=" + this.helpers.RTH(i) + ">>" + this.helpers.RS(i) + ";" + this.helpers.tRD(i) + "=" + this.helpers.RT(i) + ">>>" + this.helpers.RS(i) + ";";
      return string += this.helpers.tRD(i) + "|=temp;}";
    }

    r4300i_dsll32(i) {
      return this.helpers.tRDH(i) + "=" + this.helpers.RT(i) + "<<" + this.helpers.sa(i) + ";" + this.helpers.tRD(i) + "=0;";
    }

    r4300i_dsrl32(i) {
      return this.helpers.tRDH(i) + "=0;" + this.helpers.RD(i) + "=" + this.helpers.RT(i) + ">>>" + this.helpers.sa(i) + ";";
    }

    r4300i_dsra32(i) {
      return this.helpers.tRD(i) + "=" + this.helpers.RTH(i) + ">>" + this.helpers.sa(i) + ";" + this.helpers.tRDH(i) + "=" + this.helpers.RTH(i) + ">>31;";
    }

    r4300i_ddivu(i) {
      return "t.helpers.inter_ddivu(r,h," + i + ");";
    }

    r4300i_ddiv(i) {
      return "t.helpers.inter_ddiv(r,h," + i + ");";
    }

    r4300i_dadd(i) {
      this.log("todo: dadd");
      return "";
    }

    r4300i_break(i) {
      this.log("todo: break");
      return "";
    }

    r4300i_div(i) {
      return "t.helpers.inter_div(r,h," + i + ");";
    }

    r4300i_divu(i) {
      return "t.helpers.inter_divu(r,h," + i + ");";
    }

    r4300i_sra(i) {
      var string;
      //optimization: sra's r[hi] can safely right-shift RT.
      string = this.helpers.tRDH(i) + "=" + this.helpers.RT(i) + ">>31;";
      if (this.helpers.rd(i) === this.helpers.rt(i)) {
        string += this.helpers.tRD(i) + ">>=" + this.helpers.sa(i) + ";";
      } else {
        string += this.helpers.tRD(i) + "=" + this.helpers.RT(i) + ">>" + this.helpers.sa(i) + ";";
      }
      return string;
    }

    r4300i_COP0_tlbwi(i) {
      return "t.helpers.inter_tlbwi(t.cp0[" + consts.INDEX + "], t.tlb, t.cp0);";
    }

    r4300i_COP0_tlbp(i) {
      return "t.helpers.inter_tlbp(t.tlb, t.cp0);";
    }

    r4300i_COP0_tlbr(i) {
      return "t.helpers.inter_tlbr(t.tlb, t.cp0);";
    }

    r4300i_COP0_tlbwr(i) {
      this.log("todo: r4300i_COP0_tlbwr");
      return "";
    }

    r4300i_COP1_dmfc1(i) {
      this.log("todo: r4300i_COP1_dmfc1");
      return "";
    }

    r4300i_COP1_dmtc1(i) {
      this.log("todo: r4300i_COP1_dmtc1");
      return "";
    }

    r4300i_lwl(i) {
      var string;
      string = "{" + this.helpers.setVAddr(i);
      string += "const vAddrAligned=(r[38]&-4)|0;const value=m.lw(vAddrAligned);";
      // r[38] = vAddress
      string += "const cas=r[38]&3;const mask=-1>>>(24-(cas<<3))>>>8;const shf=(cas<<3);";
      string += this.helpers.tRT(i) + "&=mask;" + this.helpers.tRT(i) + "|=((value<<shf)>>>0);";
      //    string += "switch(r[38]&3){case 0:" + @helpers.tRT(i) + "=value;break;"
      //    string += "case 1:" + @helpers.tRT(i) + "=(" + @helpers.RT(i) + "&0x000000ff)|((value<<8)>>>0);break;"
      //    string += "case 2:" + @helpers.tRT(i) + "=(" + @helpers.RT(i) + "&0x0000ffff)|((value<<16)>>>0);break;"
      //    string += "case 3:" + @helpers.tRT(i) + "=(" + @helpers.RT(i) + "&0x00ffffff)|((value<<24)>>>0);break;}"
      return string += this.helpers.tRTH(i) + "=" + this.helpers.RT(i) + ">>31}";
    }

    // r4300i_lwr: (i) ->
    //   string = "{" + @helpers.setVAddr(i)
    //   string += "var vAddrAligned=(r[38]&0xfffffffc)|0;var value=m.lw(vAddrAligned);"
    //   string += "switch(r[38]&3){"
    //   string += "case 0:" + @helpers.tRT(i) + "=(" + @helpers.RT(i) + "&0xffffff00)|(value>>>24);break;"
    //   string += "case 1:" + @helpers.tRT(i) + "=(" + @helpers.RT(i) + "&0xffff0000)|(value>>>16);break;"
    //   string += "case 2:" + @helpers.tRT(i) + "=(" + @helpers.RT(i) + "&0xff000000)|(value>>>8);break;"
    //   string += "case 3:" + @helpers.tRT(i) + "=value;break;}"
    //   string += @helpers.tRTH(i) + "=" + @helpers.RT(i) + ">>31}"
    r4300i_lwr(i) {
      var string;
      string = "{" + this.helpers.setVAddr(i);
      string += "const vAddrAligned=(r[38]&-4)|0;const value=m.lw(vAddrAligned);";
      // do not try to optimize further. 24<<8 is 32 but -1<<32 is not the same as -1<<24<<8.
      // in other words, shifting left by 32 requires 2 operations.
      // normally, you would not shift at all if it's 32, and we'd just set the target to 0, 
      // but we don't know if the shift amount is 32 until runtime,
      // and the optimization here is avoiding the switch (and thus the branching).
      // if we propagate constants, we could potentially know the shift amount sometimes.
      string += "const cas=r[38]&3;const mask=-1<<(cas<<3)<<8;const shf=32-((cas+1)<<3);";
      string += this.helpers.tRT(i) + "&=mask;" + this.helpers.tRT(i) + "|=(value>>>shf);";
      return string += this.helpers.tRTH(i) + "=" + this.helpers.RT(i) + ">>31}";
    }

    r4300i_swl(i) {
      var string;
      string = "{" + this.helpers.setVAddr(i);
      string += "const vAddrAligned=(r[38]&-4)|0;let value=m.lw(vAddrAligned);";
      string += "switch(r[38]&3){case 0:value=" + this.helpers.RT(i) + ";break;";
      string += "case 1:value=((value&0xff000000)|(" + this.helpers.RT(i) + ">>>8));break;";
      string += "case 2:value=((value&0xffff0000)|(" + this.helpers.RT(i) + ">>>16));break;";
      string += "case 3:value=((value&0xffffff00)|(" + this.helpers.RT(i) + ">>>24));break;}";
      return string += "m.sw(value,vAddrAligned,false)}";
    }

    r4300i_swr(i) {
      var string;
      string = "{" + this.helpers.setVAddr(i);
      string += "const vAddrAligned=(r[38]&-4)|0;let value=m.lw(vAddrAligned);";
      string += "switch(r[38]&3){case 3:value=" + this.helpers.RT(i) + ";break;";
      string += "case 2:value=((value & 0xFF)|((" + this.helpers.RT(i) + "<<8)>>>0));break;";
      string += "case 1:value=((value & 0xFFFF)|((" + this.helpers.RT(i) + "<<16)>>>0));break;";
      string += "case 0:value=((value & 0xFFFFFF)|((" + this.helpers.RT(i) + "<<24)>>>0));break;}";
      return string += "m.sw(value,vAddrAligned,false)}";
    }

    r4300i_lwc1(i) {
      return "t.cp1_i[" + this.helpers.FT32ArrayView(i) + "]=m.lw(" + this.helpers.RS(i) + "+" + this.helpers.soffset_imm(i) + ");";
    }

    r4300i_ldc1(i) {
      var string;
      string = this.helpers.setVAddr(i) + "t.cp1_i[" + this.helpers.FT32ArrayView(i) + "]=m.lw((r[38]+4)|0);";
      return string += "t.cp1_i[" + this.helpers.FT32HIArrayView(i) + "]=m.lw((r[38])|0);";
    }

    r4300i_swc1(i, isDelaySlot) {
      var a, string;
      a = void 0;
      string = "m.sw(t.cp1_i[" + this.helpers.FT32ArrayView(i) + "]," + this.helpers.RS(i) + "+" + this.helpers.soffset_imm(i);
      //So we can process exceptions
      if (isDelaySlot === true) {
        a = (this.p[0] + offset + 4) | 0;
        string += "," + a + ",true);";
      } else {
        a = (this.p[0] + offset) | 0;
        string += "," + a + ");";
      }
      return string;
    }

    r4300i_sdc1(i, isDelaySlot) {
      var a, string;
      a = void 0;
      string = this.helpers.setVAddr(i) + "m.sw(t.cp1_i[" + this.helpers.FT32ArrayView(i) + "],(r[38]+4)|0";
      //So we can process exceptions
      if (isDelaySlot === true) {
        a = (this.p[0] + offset + 4) | 0;
        string += "," + a + ",true);";
      } else {
        a = (this.p[0] + offset) | 0;
        string += "," + a + ");";
      }
      string += "m.sw(t.cp1_i[" + this.helpers.FT32HIArrayView(i) + "],(r[38])|0";
      //So we can process exceptions
      if (isDelaySlot === true) {
        a = (this.p[0] + offset + 4) | 0;
        string += "," + a + ",true);";
      } else {
        a = (this.p[0] + offset) | 0;
        string += "," + a + ");";
      }
      return string;
    }

    r4300i_COP1_mtc1(i) {
      return "t.cp1_i[" + this.helpers.FS32ArrayView(i) + "]=" + this.helpers.RT(i) + ";";
    }

    r4300i_COP1_mfc1(i) {
      return this.helpers.tRTH(i) + "=(" + this.helpers.tRT(i) + "=t.cp1_i[" + this.helpers.FS32ArrayView(i) + "])>>31;";
    }

    r4300i_COP1_cvts_w(i) {
      return "t.cp1_f[" + this.helpers.FD32ArrayView(i) + "]=t.cp1_i[" + this.helpers.FS32ArrayView(i) + "];";
    }

    r4300i_COP1_cvts_l(i) {
      this.log("todo: r4300i_COP1_cvts_l");
      return "";
    }

    r4300i_COP1_cvtd_l(i) {
      this.log("todo: r4300i_COP1_cvtd_l");
      return "";
    }

    r4300i_COP1_cvtw_s(i) {
      return "t.cp1_i[" + this.helpers.FD32ArrayView(i) + "]=t.cp1_f[" + this.helpers.FS32ArrayView(i) + "];";
    }

    r4300i_COP1_div_s(i) {
      return "t.cp1_f[" + this.helpers.FD32ArrayView(i) + "]=t.cp1_f[" + this.helpers.FS32ArrayView(i) + "]/t.cp1_f[" + this.helpers.FT32ArrayView(i) + "];";
    }

    r4300i_COP1_div_d(i) {
      return "t.cp1_f64[" + this.helpers.FD64ArrayView(i) + "]=t.cp1_f64[" + this.helpers.FS64ArrayView(i) + "]/t.cp1_f64[" + this.helpers.FT64ArrayView(i) + "];";
    }

    r4300i_COP1_mul_s(i) {
      return "t.cp1_f[" + this.helpers.FD32ArrayView(i) + "]=t.cp1_f[" + this.helpers.FS32ArrayView(i) + "]*t.cp1_f[" + this.helpers.FT32ArrayView(i) + "];";
    }

    r4300i_COP1_mul_d(i) {
      return "t.cp1_f64[" + this.helpers.FD64ArrayView(i) + "]=t.cp1_f64[" + this.helpers.FS64ArrayView(i) + "]*t.cp1_f64[" + this.helpers.FT64ArrayView(i) + "];";
    }

    r4300i_COP1_mov_s(i) {
      return "t.cp1_i[" + this.helpers.FD32ArrayView(i) + "]=t.cp1_i[" + this.helpers.FS32ArrayView(i) + "];";
    }

    r4300i_COP1_mov_d(i) {
      return "t.cp1_f64[" + this.helpers.FD32ArrayView(i) + "]=t.cp1_f64[" + this.helpers.FS32ArrayView(i) + "];";
    }

    r4300i_COP1_add_s(i) {
      return "t.cp1_f[" + this.helpers.FD32ArrayView(i) + "]=t.cp1_f[" + this.helpers.FS32ArrayView(i) + "]+t.cp1_f[" + this.helpers.FT32ArrayView(i) + "];";
    }

    r4300i_COP1_sub_s(i) {
      return "t.cp1_f[" + this.helpers.FD32ArrayView(i) + "]=t.cp1_f[" + this.helpers.FS32ArrayView(i) + "]-t.cp1_f[" + this.helpers.FT32ArrayView(i) + "];";
    }

    r4300i_COP1_cvtd_s(i) {
      return "t.cp1_f64[" + this.helpers.FD64ArrayView(i) + "]=t.cp1_f[" + this.helpers.FS32ArrayView(i) + "];";
    }

    r4300i_COP1_cvtd_w(i) {
      return "t.cp1_f64[" + this.helpers.FD64ArrayView(i) + "]=t.cp1_i[" + this.helpers.FS32ArrayView(i) + "];";
    }

    r4300i_COP1_cvts_d(i) {
      return "t.cp1_f[" + this.helpers.FD32ArrayView(i) + "]=t.cp1_f64[" + this.helpers.FS64ArrayView(i) + "];";
    }

    r4300i_COP1_cvtw_d(i) {
      return "t.cp1_i[" + this.helpers.FD32ArrayView(i) + "]=t.cp1_f64[" + this.helpers.FS64ArrayView(i) + "];";
    }

    r4300i_COP1_add_d(i) {
      return "t.cp1_f64[" + this.helpers.FD64ArrayView(i) + "]=t.cp1_f64[" + this.helpers.FS64ArrayView(i) + "]+t.cp1_f64[" + this.helpers.FT64ArrayView(i) + "];";
    }

    r4300i_COP1_sub_d(i) {
      return "t.cp1_f64[" + this.helpers.FD64ArrayView(i) + "]=t.cp1_f64[" + this.helpers.FS64ArrayView(i) + "]-t.cp1_f64[" + this.helpers.FT64ArrayView(i) + "];";
    }

    //todo:rounding
    r4300i_COP1_truncw_d(i) {
      return "t.cp1_i[" + this.helpers.FD32ArrayView(i) + "]=t.cp1_f64[" + this.helpers.FS64ArrayView(i) + "];";
    }

    r4300i_COP1_truncw_s(i) {
      return "t.cp1_i[" + this.helpers.FD32ArrayView(i) + "]=t.cp1_f[" + this.helpers.FS32ArrayView(i) + "];";
    }

    r4300i_COP1_neg_s(i) {
      return "t.cp1_i[" + this.helpers.FD32ArrayView(i) + "]=t.cp1_i[" + this.helpers.FS32ArrayView(i) + "]^0x80000000;";
    }

    r4300i_COP1_neg_d(i) {
      return "t.cp1_i[" + this.helpers.FD32HIArrayView(i) + "]=t.cp1_i[" + this.helpers.FS32HIArrayView(i) + "]^0x80000000;";
    }

    r4300i_COP1_abs_s(i) {
      return "t.cp1_i[" + this.helpers.FD32ArrayView(i) + "]=t.cp1_i[" + this.helpers.FS32ArrayView(i) + "]&0x7fffffff;";
    }

    r4300i_COP1_abs_d(i) {
      return "t.cp1_i[" + this.helpers.FD32HIArrayView(i) + "]=t.cp1_i[" + this.helpers.FS32HIArrayView(i) + "]&0x7fffffff;";
    }

    r4300i_COP1_sqrt_s(i) {
      return "t.cp1_f[" + this.helpers.FD32ArrayView(i) + "]=Math.sqrt(t.cp1_f[" + this.helpers.FS32ArrayView(i) + "]);";
    }

    r4300i_COP1_sqrt_d(i) {
      return "t.cp1_f64[" + this.helpers.FD64ArrayView(i) + "]=Math.sqrt(t.cp1_f64[" + this.helpers.FS64ArrayView(i) + "]);";
    }

    r4300i_COP1_cvtl_s(i) {
      this.log("todo: r4300i_COP1_cvtl_s");
      return "";
    }

    r4300i_COP1_roundl_s(i) {
      this.log("todo: r4300i_COP1_roundl_s");
      return "";
    }

    r4300i_COP1_truncl_s(i) {
      this.log("todo: r4300i_COP1_truncl_s");
      return "";
    }

    r4300i_COP1_ceill_s(i) {
      this.log("todo: r4300i_COP1_ceill_s");
      return "";
    }

    r4300i_COP1_floorl_s(i) {
      this.log("todo: r4300i_COP1_floorl_s");
      return "";
    }

    r4300i_COP1_roundw_s(i) {
      this.log("todo: r4300i_COP1_floorl_s");
      return "";
    }

    r4300i_COP1_ceilw_s(i) {
      this.log("todo: r4300i_COP1_floorl_s");
      return "";
    }

    r4300i_COP1_floorw_s(i) {
      this.log("todo: r4300i_COP1_floorl_s");
      return "";
    }

    r4300i_COP1_cvtl_d(i) {
      this.log("todo: r4300i_COP1_cvtl_s");
      return "";
    }

    r4300i_COP1_roundl_d(i) {
      this.log("todo: r4300i_COP1_roundl_d");
      return "";
    }

    r4300i_COP1_truncl_d(i) {
      this.log("todo: r4300i_COP1_truncl_d");
      return "";
    }

    r4300i_COP1_ceill_d(i) {
      this.log("todo: r4300i_COP1_ceill_d");
      return "";
    }

    r4300i_COP1_floorl_d(i) {
      this.log("todo: r4300i_COP1_floorl_d");
      return "";
    }

    r4300i_COP1_roundw_d(i) {
      this.log("todo: r4300i_COP1_floorl_d");
      return "";
    }

    r4300i_COP1_ceilw_d(i) {
      this.log("todo: r4300i_COP1_floorl_d");
      return "";
    }

    r4300i_COP1_floorw_d(i) {
      this.log("todo: r4300i_COP1_floorl_d");
      return "";
    }

    r4300i_sync(i) {
      this.log("todo: sync");
      return "";
    }

    r4300i_sdr(i) {
      this.log("todo: sdr");
      return "";
    }

    r4300i_ldr(i) {
      this.log("todo: ldr");
      return "";
    }

    r4300i_sdl(i) {
      this.log("todo: sdl");
      return "";
    }

    r4300i_ldl(i) {
      this.log("todo: ldl");
      return "";
    }

    r4300i_sc(i) {
      this.log("todo: sc");
      return "";
    }

    r4300i_scd(i) {
      this.log("todo: scd");
      return "";
    }

    r4300i_daddi(i) {
      return "t.helpers.inter_daddi(r,h," + i + ");";
    }

    r4300i_teq(i) {
      this.log("todo: r4300i_teq");
      return "";
    }

    r4300i_tgeu(i) {
      this.log("todo: r4300i_tgeu");
      return "";
    }

    r4300i_tgei(i) {
      this.log("todo: r4300i_tgei");
      return "";
    }

    r4300i_tgeiu(i) {
      this.log("todo: r4300i_tgeiu");
      return "";
    }

    r4300i_tlt(i) {
      this.log("todo: r4300i_tlt");
      return "";
    }

    r4300i_tltu(i) {
      this.log("todo: r4300i_tltu");
      return "";
    }

    r4300i_tne(i) {
      this.log("todo: r4300i_tne");
      return "";
    }

    r4300i_tnei(i) {
      this.log("todo: r4300i_tnei");
      return "";
    }

    r4300i_tlti(i) {
      this.log("todo: r4300i_tlti");
      return "";
    }

    r4300i_tltiu(i) {
      this.log("todo: r4300i_tltiu");
      return "";
    }

    r4300i_teqi(i) {
      this.log("todo: r4300i_teqi");
      return "";
    }

    r4300i_bltzal(i) {
      this.log("todo: r4300i_bltzal (might be unused)");
      return "";
    }

    r4300i_bltzall(i) {
      this.log("todo: r4300i_teqi (might be unused)");
      return "";
    }

    //using same as daddi
    r4300i_daddiu(i) {
      return "t.helpers.inter_daddiu(r,h," + i + ");";
    }

    r4300i_daddu(i) {
      return "t.helpers.inter_daddu(r,h," + i + ");";
    }

    r4300i_dsub(i) {
      this.log("todo: r4300i_dsub");
      return "";
    }

    r4300i_dsubu(i) {
      this.log("todo: r4300i_dsubu");
      return "";
    }

    r4300i_tge(i) {
      this.log("todo: r4300i_tge");
      return "";
    }

    r4300i_C_F_S(i) {
      return "t.helpers.inter_r4300i_C_cond_fmt_s(" + i + ",t.cp1Con,t.cp1_f);";
    }

    r4300i_C_UN_S(i) {
      return "t.helpers.inter_r4300i_C_cond_fmt_s(" + i + ",t.cp1Con,t.cp1_f);";
    }

    r4300i_C_EQ_S(i) {
      return "t.helpers.inter_r4300i_C_cond_fmt_s(" + i + ",t.cp1Con,t.cp1_f);";
    }

    r4300i_C_UEQ_S(i) {
      return "t.helpers.inter_r4300i_C_cond_fmt_s(" + i + ",t.cp1Con,t.cp1_f);";
    }

    r4300i_C_OLT_S(i) {
      return "t.helpers.inter_r4300i_C_cond_fmt_s(" + i + ",t.cp1Con,t.cp1_f);";
    }

    r4300i_C_ULT_S(i) {
      return "t.helpers.inter_r4300i_C_cond_fmt_s(" + i + ",t.cp1Con,t.cp1_f);";
    }

    r4300i_C_OLE_S(i) {
      return "t.helpers.inter_r4300i_C_cond_fmt_s(" + i + ",t.cp1Con,t.cp1_f);";
    }

    r4300i_C_ULE_S(i) {
      return "t.helpers.inter_r4300i_C_cond_fmt_s(" + i + ",t.cp1Con,t.cp1_f);";
    }

    r4300i_C_SF_S(i) {
      return "t.helpers.inter_r4300i_C_cond_fmt_s(" + i + ",t.cp1Con,t.cp1_f);";
    }

    r4300i_C_NGLE_S(i) {
      return "t.helpers.inter_r4300i_C_cond_fmt_s(" + i + ",t.cp1Con,t.cp1_f);";
    }

    r4300i_C_SEQ_S(i) {
      return "t.helpers.inter_r4300i_C_cond_fmt_s(" + i + ",t.cp1Con,t.cp1_f);";
    }

    r4300i_C_NGL_S(i) {
      return "t.helpers.inter_r4300i_C_cond_fmt_s(" + i + ",t.cp1Con,t.cp1_f);";
    }

    r4300i_C_LT_S(i) {
      return "t.helpers.inter_r4300i_C_cond_fmt_s(" + i + ",t.cp1Con,t.cp1_f);";
    }

    r4300i_C_NGE_S(i) {
      return "t.helpers.inter_r4300i_C_cond_fmt_s(" + i + ",t.cp1Con,t.cp1_f);";
    }

    r4300i_C_LE_S(i) {
      return "t.helpers.inter_r4300i_C_cond_fmt_s(" + i + ",t.cp1Con,t.cp1_f);";
    }

    r4300i_C_NGT_S(i) {
      return "t.helpers.inter_r4300i_C_cond_fmt_s(" + i + ",t.cp1Con,t.cp1_f);";
    }

    r4300i_C_F_D(i) {
      return "t.helpers.inter_r4300i_C_cond_fmt_d(" + i + ",t.cp1Con,t.cp1_f64);";
    }

    r4300i_C_UN_D(i) {
      return "t.helpers.inter_r4300i_C_cond_fmt_d(" + i + ",t.cp1Con,t.cp1_f64);";
    }

    r4300i_C_EQ_D(i) {
      return "t.helpers.inter_r4300i_C_cond_fmt_d(" + i + ",t.cp1Con,t.cp1_f64);";
    }

    r4300i_C_UEQ_D(i) {
      return "t.helpers.inter_r4300i_C_cond_fmt_d(" + i + ",t.cp1Con,t.cp1_f64);";
    }

    r4300i_C_OLT_D(i) {
      return "t.helpers.inter_r4300i_C_cond_fmt_d(" + i + ",t.cp1Con,t.cp1_f64);";
    }

    r4300i_C_ULT_D(i) {
      return "t.helpers.inter_r4300i_C_cond_fmt_d(" + i + ",t.cp1Con,t.cp1_f64);";
    }

    r4300i_C_OLE_D(i) {
      return "t.helpers.inter_r4300i_C_cond_fmt_d(" + i + ",t.cp1Con,t.cp1_f64);";
    }

    r4300i_C_ULE_D(i) {
      return "t.helpers.inter_r4300i_C_cond_fmt_d(" + i + ",t.cp1Con,t.cp1_f64);";
    }

    r4300i_C_SF_D(i) {
      return "t.helpers.inter_r4300i_C_cond_fmt_d(" + i + ",t.cp1Con,t.cp1_f64);";
    }

    r4300i_C_NGLE_D(i) {
      return "t.helpers.inter_r4300i_C_cond_fmt_d(" + i + ",t.cp1Con,t.cp1_f64);";
    }

    r4300i_C_SEQ_D(i) {
      return "t.helpers.inter_r4300i_C_cond_fmt_d(" + i + ",t.cp1Con,t.cp1_f64);";
    }

    r4300i_C_NGL_D(i) {
      return "t.helpers.inter_r4300i_C_cond_fmt_d(" + i + ",t.cp1Con,t.cp1_f64);";
    }

    r4300i_C_LT_D(i) {
      return "t.helpers.inter_r4300i_C_cond_fmt_d(" + i + ",t.cp1Con,t.cp1_f64);";
    }

    r4300i_C_NGE_D(i) {
      return "t.helpers.inter_r4300i_C_cond_fmt_d(" + i + ",t.cp1Con,t.cp1_f64);";
    }

    r4300i_C_LE_D(i) {
      return "t.helpers.inter_r4300i_C_cond_fmt_d(" + i + ",t.cp1Con,t.cp1_f64);";
    }

    r4300i_C_NGT_D(i) {
      return "t.helpers.inter_r4300i_C_cond_fmt_d(" + i + ",t.cp1Con,t.cp1_f64);";
    }

  };

  //hack global space until we export classes properly
  //node.js uses exports; browser uses this (window)
  root = typeof exports !== "undefined" && exports !== null ? exports : self;

  root.C1964jsEmulator = C1964jsEmulator;

  root.consts = consts;

}).call(this);
