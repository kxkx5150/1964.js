// Generated by CoffeeScript 2.5.1
(function() {
  /*1964js - JavaScript/HTML5 port of 1964 - N64 emulator
  Copyright (C) 2012 Joel Middendorf

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.*/
  var C1964jsHelpers, root;

  /////////////////
  //Operand helpers
  /////////////////

  //jslint bitwise: true, devel: true, todo: true
  //global consts
  //global goog, BigInt, bigint_mul, bigint_div, bigint_mod
  C1964jsHelpers = function(core, isLittleEndian) {
    "use strict";
    this.core = core;
    this.isLittleEndian = isLittleEndian;
    this.isBigEndian = isLittleEndian === false;
    this.fs = function(i) {
      return i >> 11 & 0x1f;
    };
    this.ft = function(i) {
      return i >> 16 & 0x1f;
    };
    this.FS32ArrayView = function(i) {
      return (i >> 11 & 0x1f) ^ this.isBigEndian;
    };
    this.FS32HIArrayView = function(i) {
      return (i >> 11 & 0x1f) ^ this.isLittleEndian;
    };
    this.FT32ArrayView = function(i) {
      return (i >> 16 & 0x1f) ^ this.isBigEndian;
    };
    this.FT32HIArrayView = function(i) {
      return (i >> 16 & 0x1f) ^ this.isLittleEndian;
    };
    this.FD32ArrayView = function(i) {
      return (i >> 6 & 0x1F) ^ this.isBigEndian;
    };
    this.FD32HIArrayView = function(i) {
      return (i >> 6 & 0x1f) ^ this.isLittleEndian;
    };
    this.FS64ArrayView = function(i) {
      return (i >> 11 & 0x1f) >> 1;
    };
    this.FT64ArrayView = function(i) {
      return (i >> 16 & 0x1f) >> 1;
    };
    this.FD64ArrayView = function(i) {
      return (i >> 6 & 0x1F) >> 1;
    };
    this.rd = function(i) {
      return i >> 11 & 0x1f;
    };
    this.rs = function(i) {
      return i >> 21 & 0x1f;
    };
    this.RS = function(i) {
      var reg;
      reg = i >> 21 & 0x1f;
      if (reg === 0) {
        return "~-1";
      }
      return "r[" + reg + "]";
    };
    this.RSH = function(i) {
      var reg;
      reg = i >> 21 & 0x1f;
      if (reg === 0) {
        return "~-1";
      }
      return "h[" + reg + "]";
    };
    this.uRS = function(i) {
      var reg;
      reg = i >> 21 & 0x1f;
      if (reg === 0) {
        return "~-1";
      }
      return "(r[" + reg + "]>>>0)";
    };
    this.uRSH = function(i) {
      var reg;
      reg = i >> 21 & 0x1f;
      if (reg === 0) {
        return "~-1";
      }
      return "(h[" + reg + "]>>>0)";
    };
    this.tRS = function(i) {
      var reg;
      reg = i >> 21 & 0x1f;
      if (reg === 0) {
        return "r[34]";
      }
      return "r[" + reg + "]";
    };
    this.tRSH = function(i) {
      var reg;
      reg = i >> 21 & 0x1f;
      if (reg === 0) {
        return "h[34]";
      }
      return "h[" + reg + "]";
    };
    this.tRD = function(i) {
      var reg;
      reg = i >> 11 & 0x1f;
      if (reg === 0) {
        return "r[34]";
      }
      return "r[" + reg + "]";
    };
    this.tRDH = function(i) {
      var reg;
      reg = i >> 11 & 0x1f;
      if (reg === 0) {
        return "h[34]";
      }
      return "h[" + reg + "]";
    };
    this.tRT = function(i) {
      var reg;
      reg = i >> 16 & 0x1f;
      if (reg === 0) {
        return "r[34]";
      }
      return "r[" + reg + "]";
    };
    this.tRTH = function(i) {
      var reg;
      reg = i >> 16 & 0x1f;
      if (reg === 0) {
        return "h[34]";
      }
      return "h[" + reg + "]";
    };
    this.RD = function(i) {
      var reg;
      reg = i >> 11 & 0x1f;
      if (reg === 0) {
        return "~-1";
      }
      return "r[" + reg + "]";
    };
    this.RDH = function(i) {
      var reg;
      reg = i >> 11 & 0x1f;
      if (reg === 0) {
        return "~-1";
      }
      return "h[" + reg + "]";
    };
    this.uRD = function(i) {
      var reg;
      reg = i >> 11 & 0x1f;
      if (reg === 0) {
        return "~-1";
      }
      return "(r[" + reg + "]>>>0)";
    };
    this.uRDH = function(i) {
      var reg;
      reg = i >> 11 & 0x1f;
      if (reg === 0) {
        return "~-1";
      }
      return "(h[" + reg + "]>>>0)";
    };
    this.RT = function(i) {
      var reg;
      reg = i >> 16 & 0x1f;
      if (reg === 0) {
        return "~-1";
      }
      return "r[" + reg + "]";
    };
    this.RTH = function(i) {
      var reg;
      reg = i >> 16 & 0x1f;
      if (reg === 0) {
        return "~-1";
      }
      return "h[" + reg + "]";
    };
    this.uRT = function(i) {
      var reg;
      reg = i >> 16 & 0x1f;
      if (reg === 0) {
        return "~-1";
      }
      return "(r[" + reg + "]>>>0)";
    };
    this.uRTH = function(i) {
      var reg;
      reg = i >> 16 & 0x1f;
      if (reg === 0) {
        return "~-1";
      }
      return "(h[" + reg + "]>>>0)";
    };
    this.rt = function(i) {
      return i >> 16 & 0x1f;
    };
    this.offset_imm = function(i) {
      return i & 0xffff;
    };
    this.soffset_imm = function(i) {
      return i << 16 >> 16;
    };
    this.setVAddr = function(i) {
      return "r[38]=" + this.RS(i) + "+" + this.soffset_imm(i) + ";";
    };
    this.fn = function(i) {
      return i & 0x3f;
    };
    this.sa = function(i) {
      return i >> 6 & 0x1F;
    };
    this.fd = function(i) {
      return i >> 6 & 0x1F;
    };
    this.sLogic = function(i, n) {
      if (this.rd(i) === this.rs(i)) {
        return this.tRD(i) + n + "=" + this.RT(i) + ";" + this.tRDH(i) + "=" + this.RD(i) + ">>31;";
      } else {
        return this.tRD(i) + "=" + this.RS(i) + n + this.RT(i) + ";" + this.tRDH(i) + "=" + this.RD(i) + ">>31;";
      }
    };
    this.dLogic = function(i, n) {
      if (this.rd(i) === this.rs(i)) {
        return this.tRD(i) + n + "=" + this.RT(i) + ";" + this.tRDH(i) + n + "=" + this.RTH(i) + ";";
      } else {
        return this.tRD(i) + "=" + this.RS(i) + n + this.RT(i) + ";" + this.tRDH(i) + "=" + this.RSH(i) + n + this.RTH(i) + ";";
      }
    };
    this.virtualToPhysical = function(addr) {
      return "r[35]=" + addr + ";r[36]=(m.t[r[35]>>>12]<<16)|(r[35]&0xffff);";
    };
    ////////////////////////////
    //Interpreted opcode helpers
    ////////////////////////////

    //called function, not compiled
    this.inter_mtc0 = function(r, f, rt, isDelaySlot, pc, cp0, interrupts) {
      //incomplete:
      switch (f) {
        case consts.CAUSE:
          cp0[f] &= ~0x300;
          cp0[f] |= r[rt] & 0x300;
          if ((cp0[consts.CAUSE] & cp0[consts.STATUS] & 0x0000FF00) !== 0 && (r[rt] & 0x300) !== 0) {
            //      if (((r[rt] & 1)===1) && (cp0[f] & 1)===0) //possible fix over 1964cpp?
            interrupts.setException(consts.EXC_INT, 0, pc, isDelaySlot);
          }
          break;
        //interrupts.processException(pc, isDelaySlot);
        case consts.COUNT:
          cp0[f] = r[rt];
          break;
        case consts.COMPARE:
          cp0[consts.CAUSE] &= ~consts.CAUSE_IP8;
          cp0[f] = r[rt];
          break;
        case consts.STATUS:
          if (((r[rt] & consts.EXL) === 0) && ((cp0[f] & consts.EXL) === 1)) {
            if ((cp0[consts.CAUSE] & cp0[consts.STATUS] & 0x0000FF00) !== 0) {
              cp0[f] = r[rt];
              interrupts.setException(consts.EXC_INT, 0, pc, isDelaySlot);
              return;
            }
          }
          //interrupts.processException(pc, isDelaySlot);
          if (((r[rt] & consts.IE) === 1) && ((cp0[f] & consts.IE) === 0)) {
            if ((cp0[consts.CAUSE] & cp0[consts.STATUS] & 0x0000FF00) !== 0) {
              cp0[f] = r[rt];
              interrupts.setException(consts.EXC_INT, 0, pc, isDelaySlot);
              return;
            }
          }
          //interrupts.processException(pc, isDelaySlot);
          cp0[f] = r[rt];
          break;
        //tlb:
        case consts.BADVADDR:
        case consts.PREVID:
        case consts.RANDOM:
          break;
        case consts.INDEX:
          cp0[f] = r[rt] & 0x8000003F;
          break;
        case consts.ENTRYLO0:
          cp0[f] = r[rt] & 0x3FFFFFFF;
          break;
        case consts.ENTRYLO1:
          cp0[f] = r[rt] & 0x3FFFFFFF;
          break;
        case consts.ENTRYHI:
          cp0[f] = r[rt] & 0xFFFFE0FF;
          break;
        case consts.PAGEMASK:
          cp0[f] = r[rt] & 0x01FFE000;
          break;
        case consts.WIRED:
          cp0[f] = r[rt] & 0x1f;
          cp0[consts.RANDOM] = 0x1f;
          break;
        default:
          cp0[f] = r[rt];
      }
    };
    this.inter_mult = function(r, h, i) {
      var r1, r2, res, rs32, rt32;
      res = void 0;
      r1 = void 0;
      r2 = void 0;
      rt32 = void 0;
      rs32 = r[this.rs(i)];
      rt32 = r[this.rt(i)];
      r1 = goog.math.Long.fromBits(rs32, rs32 >> 31);
      r2 = goog.math.Long.fromBits(rt32, rt32 >> 31);
      res = r1.multiply(r2);
      r[32] = res.getLowBits(); //lo
      h[32] = r[32] >> 31;
      r[33] = res.getHighBits(); //hi
      h[33] = r[33] >> 31;
    };
    this.inter_multu = function(r, h, i) {
      var r1, r2, res, rs32, rt32;
      res = void 0;
      r1 = void 0;
      r2 = void 0;
      rt32 = void 0;
      rs32 = r[this.rs(i)];
      rt32 = r[this.rt(i)];
      r1 = goog.math.Long.fromBits(rs32, 0);
      r2 = goog.math.Long.fromBits(rt32, 0);
      res = r1.multiply(r2);
      r[32] = res.getLowBits(); //lo
      h[32] = r[32] >> 31;
      r[33] = res.getHighBits(); //hi
      h[33] = r[33] >> 31;
    };
    //    alert('multu: '+r[this.rs(i)]+'*'+r[this.rt(i)]+'='+dec2hex(h[33]) +' '+dec2hex(r[33])+' '+dec2hex(h[32])+' '+dec2hex(r[32]));
    this.inter_daddi = function(r, h, i) {
      var imm, rs1, rtres;
      rtres = void 0;
      imm = void 0;
      rs1 = goog.math.Long.fromBits(r[this.rs(i)], h[this.rs(i)]);
      imm = goog.math.Long.fromBits(this.soffset_imm(i), this.soffset_imm(i) >> 31);
      rtres = rs1.add(imm);
      r[this.rt(i)] = rtres.getLowBits(); //lo
      h[this.rt(i)] = rtres.getHighBits(); //hi
    };
    this.inter_daddiu = function(r, h, i) {
      var imm, rs1, rtres;
      rtres = void 0;
      imm = void 0;
      rs1 = goog.math.Long.fromBits(r[this.rs(i)], h[this.rs(i)]);
      imm = goog.math.Long.fromBits(this.soffset_imm(i), this.soffset_imm(i) >> 31);
      rtres = rs1.add(imm);
      r[this.rt(i)] = rtres.getLowBits(); //lo
      h[this.rt(i)] = rtres.getHighBits(); //hi
    };
    this.inter_dadd = function(r, h, i) {
      var rdres, rs1, rt1;
      rdres = void 0;
      rt1 = void 0;
      rs1 = goog.math.Long.fromBits(r[this.rs(i)], h[this.rs(i)]);
      rt1 = goog.math.Long.fromBits(r[this.rt(i)], h[this.rt(i)]);
      rdres = rs1.add(rt1);
      r[this.rd(i)] = rdres.getLowBits(); //lo
      h[this.rd(i)] = rdres.getHighBits(); //hi
    };
    this.inter_daddu = function(r, h, i) {
      var rdres, rs1, rt1;
      rdres = void 0;
      rt1 = void 0;
      rs1 = goog.math.Long.fromBits(r[this.rs(i)], h[this.rs(i)]);
      rt1 = goog.math.Long.fromBits(r[this.rt(i)], h[this.rt(i)]);
      rdres = rs1.add(rt1);
      r[this.rd(i)] = rdres.getLowBits(); //lo
      h[this.rd(i)] = rdres.getHighBits(); //hi
    };
    this.inter_div = function(r, h, i) {
      if (r[this.rt(i)] === 0) {
        alert("divide by zero");
        return;
      }
      //todo: handle div by zero
      r[32] = r[this.rs(i)] / r[this.rt(i)];
      h[32] = r[32] >> 31; //hi
      r[33] = r[this.rs(i)] % r[this.rt(i)];
      h[33] = r[33] >> 31; //hi
    };
    //alert('div: '+r[this.rs(i)]+'/'+r[this.rt(i)]+'='+dec2hex(h[33]) +' '+dec2hex(r[33])+' '+dec2hex(h[32])+' '+dec2hex(r[32]));
    this.inter_ddiv = function(r, h, i) {
      var mod, r1, r2, res, rs32, rsh32, rt32, rth32;
      res = void 0;
      mod = void 0;
      rsh32 = void 0;
      rth32 = void 0;
      r1 = void 0;
      r2 = void 0;
      rt32 = void 0;
      rs32 = r[this.rs(i)];
      rt32 = r[this.rt(i)];
      rsh32 = h[this.rs(i)];
      rth32 = h[this.rt(i)];
      r1 = goog.math.Long.fromBits(rs32, rsh32);
      r2 = goog.math.Long.fromBits(rt32, rth32);
      if (r2 === 0) {
        alert("divide by zero");
        return;
      }
      res = r1.div(r2);
      mod = r1.modulo(r2);
      r[32] = res.getLowBits(); //lo
      h[32] = res.getHighBits(); //hi
      r[33] = mod.getLowBits(); //lo
      h[33] = mod.getHighBits(); //hi
    };
    //alert('ddiv: '+rs64+'/'+rt64+'='+dec2hex(h[33]) +' '+dec2hex(r[33])+' '+dec2hex(h[32])+' '+dec2hex(r[32]));
    this.inter_divu = function(r, h, i) {
      if (r[this.rt(i)] === 0) {
        alert("divide by zero");
        return;
      }
      //todo: handle div by zero
      r[32] = (r[this.rs(i)] >>> 0) / (r[this.rt(i)] >>> 0); //lo
      h[32] = r[32] >> 31; //hi
      r[33] = (r[this.rs(i)] >>> 0) % (r[this.rt(i)] >>> 0); //lo
      h[33] = r[33] >> 31; //hi
    };
    //alert('divu: '+r[this.rs(i)]+'/'+r[this.rt(i)]+'='+dec2hex(h[33]) +' '+dec2hex(r[33])+' '+dec2hex(h[32])+' '+dec2hex(r[32]));
    this.inter_dmult = function(r, h, i) {
      var delim, num, rs64, rt64, x, y, z;
      //this is wrong..i think BigInt it will treat hex as unsigned?
      delim = void 0;
      x = void 0;
      y = void 0;
      z = void 0;
      num = void 0;
      rt64 = void 0;
      if (h[this.rs(i)] < 0) {
        alert("dmult RSh negative:" + h[this.rs(i)]);
      }
      if (h[this.rt(i)] < 0) {
        alert("dmult RTh negative:" + h[this.rt(i)]);
      }
      rs64 = "0x" + String(dec2hex(h[this.rs(i)])) + String(dec2hex(r[this.rs(i)]));
      rt64 = "0x" + String(dec2hex(h[this.rt(i)])) + String(dec2hex(r[this.rt(i)]));
      x = new BigInt(rs64);
      y = new BigInt(rt64);
      z = bigint_mul(x, y);
      num = z.toStringBase(16);
      if (num[0] === "-") {
        alert("dmult:" + num);
      }
      if (num.length > 24) {
        delim = num.length - 24;
        h[33] = ("0x" + num.substr(0, delim)) >>> 0; // hi of HIREG
        r[33] = ("0x" + num.substr(delim, 8)) >>> 0; // lo of HIREG
        h[32] = ("0x" + num.substr(delim + 8, 8)) >>> 0; // hi of LOREG
        r[32] = ("0x" + num.substr(delim + 16, 8)) >>> 0; // lo of LOREG
      } else if (num.length > 16) {
        delim = num.length - 16;
        h[33] = 0; // hi of HIREG
        r[33] = ("0x" + num.substr(0, delim)) >>> 0; // lo of HIREG
        h[32] = ("0x" + num.substr(delim, 8)) >>> 0; // hi of LOREG
        r[32] = ("0x" + num.substr(delim + 8, 8)) >>> 0; // lo of LOREG
      } else if (num.length > 8) {
        delim = num.length - 8;
        h[33] = 0; // hi of HIREG
        r[33] = 0; // lo of HIREG
        h[32] = ("0x" + num.substr(0, delim)) >>> 0; // hi of LOREG
        r[32] = ("0x" + num.substr(delim, 8)) >>> 0; // lo of LOREG
      } else {
        delim = num.length;
        h[33] = 0; // hi of HIREG
        r[33] = 0; // lo of HIREG
        h[32] = 0; // hi of LOREG
        r[32] = ("0x" + num.substr(0, delim)) >>> 0; // lo of LOREG
      }
    };
    //alert('dmult: '+rs64+'*'+rt64+'='+dec2hex(h[33]) +' '+dec2hex(r[33])+' '+dec2hex(h[32])+' '+dec2hex(r[32]));
    this.inter_dmultu = function(r, h, i) {
      var delim, num, rs64, rt64, x, y, z;
      //Attax demo
      delim = void 0;
      x = void 0;
      y = void 0;
      z = void 0;
      num = void 0;
      rt64 = void 0;
      rs64 = "0x0" + String(dec2hex(h[this.rs(i)])) + String(dec2hex(r[this.rs(i)]));
      rt64 = "0x0" + String(dec2hex(h[this.rt(i)])) + String(dec2hex(r[this.rt(i)]));
      x = new BigInt(rs64);
      y = new BigInt(rt64);
      z = bigint_mul(x, y);
      num = z.toStringBase(16);
      if (num[0] === "-") {
        alert("dmultu:" + num);
      }
      if (num.length > 24) {
        delim = num.length - 24;
        h[33] = ("0x" + num.substr(0, delim)) >>> 0; // hi of HIREG
        r[33] = ("0x" + num.substr(delim, 8)) >>> 0; // lo of HIREG
        h[32] = ("0x" + num.substr(delim + 8, 8)) >>> 0; // hi of LOREG
        r[32] = ("0x" + num.substr(delim + 16, 8)) >>> 0; // lo of LOREG
      } else if (num.length > 16) {
        delim = num.length - 16;
        h[33] = 0; // hi of HIREG
        r[33] = ("0x" + num.substr(0, delim)) >>> 0; // lo of HIREG
        h[32] = ("0x" + num.substr(delim, 8)) >>> 0; // hi of LOREG
        r[32] = ("0x" + num.substr(delim + 8, 8)) >>> 0; // lo of LOREG
      } else if (num.length > 8) {
        delim = num.length - 8;
        h[33] = 0; // hi of HIREG
        r[33] = 0; // lo of HIREG
        h[32] = ("0x" + num.substr(0, delim)) >>> 0; // hi of LOREG
        r[32] = ("0x" + num.substr(delim, 8)) >>> 0; // lo of LOREG
      } else {
        delim = num.length;
        h[33] = 0; // hi of HIREG
        r[33] = 0; // lo of HIREG
        h[32] = 0; // hi of LOREG
        r[32] = ("0x" + num.substr(0, delim)) >>> 0; // lo of LOREG
      }
    };
    //alert('dmultu: '+rs64+'*'+rt64+'='+dec2hex(h[33]) +' '+dec2hex(r[33])+' '+dec2hex(h[32])+' '+dec2hex(r[32]));
    this.inter_ddivu = function(r, h, i) {
      var delim, num, rs64, rt64, x, y, z;
      delim = void 0;
      x = void 0;
      y = void 0;
      z = void 0;
      num = void 0;
      rt64 = void 0;
      rs64 = "0x0" + String(dec2hex(h[this.rs(i)])) + String(dec2hex(r[this.rs(i)]));
      rt64 = "0x0" + String(dec2hex(h[this.rt(i)])) + String(dec2hex(r[this.rt(i)]));
      x = new BigInt(rs64);
      y = new BigInt(rt64);
      z = bigint_div(x, y);
      if (!z) {
        r[32] = 0;
        h[32] = 0;
      } else {
        num = z.toStringBase(16);
        if (num[0] === "-") {
          alert("ddivu:" + num);
        }
        if (num.length > 8) {
          delim = num.length - 8;
          h[32] = ("0x" + num.substr(0, delim)) >>> 0; // hi of LOREG
          r[32] = ("0x" + num.substr(delim, 8)) >>> 0; // lo of LOREG
        } else {
          delim = num.length;
          h[32] = 0; // hi of LOREG
          r[32] = ("0x" + num.substr(0, delim)) >>> 0; // lo of LOREG
        }
      }
      
      //mod
      z = bigint_mod(x, y);
      num = z.toStringBase(16);
      if (num.length > 8) {
        delim = num.length - 8;
        h[33] = ("0x" + num.substr(0, delim)) >>> 0; // hi of LOREG
        r[33] = ("0x" + num.substr(delim, 8)) >>> 0; // lo of LOREG
      } else {
        delim = num.length;
        h[33] = 0; // hi of LOREG
        r[33] = ("0x" + num.substr(0, delim)) >>> 0; // lo of LOREG
      }
    };
    //alert('ddivu: '+rs64+'/'+rt64+'='+dec2hex(h[33]) +' '+dec2hex(r[33])+' '+dec2hex(h[32])+' '+dec2hex(r[32]));
    this.inter_r4300i_C_cond_fmt_s = function(instruction, cp1Con, cp1_f) {
      var cond, cond0, cond1, cond2, cond3, equal, fcFS32, fcFT32, less, unordered;
      fcFS32 = void 0;
      fcFT32 = void 0;
      less = void 0;
      equal = void 0;
      unordered = void 0;
      cond = void 0;
      cond0 = void 0;
      cond1 = void 0;
      cond2 = void 0;
      cond3 = void 0;
      //CHK_ODD_FPR_2_REG(RD_FS, RT_FT);
      cond0 = instruction & 0x1;
      cond1 = (instruction >> 1) & 0x1;
      cond2 = (instruction >> 2) & 0x1;
      cond3 = (instruction >> 3) & 0x1;
      fcFS32 = cp1_f[this.FS32ArrayView(instruction)];
      fcFT32 = cp1_f[this.FT32ArrayView(instruction)];
      if (isNaN(fcFS32) || isNaN(fcFT32)) {
        less = false;
        equal = false;
        unordered = true;
        //Fire invalid operation exception
        if (cond3 !== 0) {
          return;
        }
      } else {
        less = fcFS32 < fcFT32;
        equal = fcFS32 === fcFT32;
        unordered = false;
      }
      cond = (cond0 && unordered) || (cond1 && equal) || (cond2 && less);
      cp1Con[31] &= ~consts.COP1_CONDITION_BIT;
      if (cond) {
        cp1Con[31] |= consts.COP1_CONDITION_BIT;
      }
    };
    this.inter_r4300i_C_cond_fmt_d = function(instruction, cp1Con, cp1_f64) {
      var cond, cond0, cond1, cond2, cond3, equal, fcFS64, fcFT64, less, unordered;
      fcFS64 = void 0;
      fcFT64 = void 0;
      less = void 0;
      equal = void 0;
      unordered = void 0;
      cond = void 0;
      cond0 = void 0;
      cond1 = void 0;
      cond2 = void 0;
      cond3 = void 0;
      // CHK_ODD_FPR_2_REG(RD_FS, RT_FT);
      cond0 = instruction & 0x1;
      cond1 = (instruction >> 1) & 0x1;
      cond2 = (instruction >> 2) & 0x1;
      cond3 = (instruction >> 3) & 0x1;
      fcFS64 = cp1_f64[this.FS64ArrayView(instruction)];
      fcFT64 = cp1_f64[this.FT64ArrayView(instruction)];
      if (isNaN(fcFS64) || isNaN(fcFT64)) {
        less = false;
        equal = false;
        unordered = true;
        //Fire invalid operation exception
        if (cond3 !== 0) {
          return;
        }
      } else {
        less = fcFS64 < fcFT64;
        equal = fcFS64 === fcFT64;
        unordered = false;
      }
      cond = (cond0 && unordered) || (cond1 && equal) || (cond2 && less);
      cp1Con[31] &= ~consts.COP1_CONDITION_BIT;
      if (cond) {
        cp1Con[31] |= consts.COP1_CONDITION_BIT;
      }
    };
    this.writeTLBEntry = function(tlb, cp0) {
      var g;
      g = cp0[consts.ENTRYLO0] & cp0[consts.ENTRYLO1] & consts.TLBLO_G;
      tlb.pageMask = cp0[consts.PAGEMASK] >>> 0;
      tlb.entryLo1 = (cp0[consts.ENTRYLO1] | g) >>> 0;
      tlb.entryLo0 = (cp0[consts.ENTRYLO0] | g) >>> 0;
      tlb.myHiMask = ((~tlb.pageMask >>> 0) & consts.TLBHI_VPN2MASK) >>> 0;
      tlb.entryHi = ((cp0[consts.ENTRYHI] >>> 0) & (~cp0[consts.PAGEMASK] >>> 0)) >>> 0;
      switch (tlb.pageMask) {
        case 0x00000000:
          tlb.loCompare = 0x00001000; //4k
          break;
        case 0x00006000:
          tlb.loCompare = 0x00004000; //16k
          break;
        case 0x0001e000:
          tlb.loCompare = 0x00010000; //64k
          break;
        case 0x0007e000:
          tlb.loCompare = 0x00040000; //256k
          break;
        case 0x001fe000:
          tlb.loCompare = 0x00100000; //1M
          break;
        case 0x007fe000:
          tlb.loCompare = 0x00400000; //4M
          break;
        case 0x01ffe000:
          tlb.loCompare = 0x01000000; //16M
          break;
        default:
          console.log("ERROR: tlbwi - invalid page size" + tlb.pageMask);
      }
      this.newtlb = true;
    };
    this.buildTLBHelper = function(start, end, entry, mask, clear) {
      var i, lend, real, realAddress;
      i = start >>> 12;
      lend = end >>> 12;
      if (clear === true) { //clear unconditionally or if (entry & 3)? If so, why?
        while (i < lend) {
          this.core.memory.t[i] = (i & 0x1ffff) >>> 4;
          i++; //if (entry & 0x3) #why?
        }
      } else {
        realAddress = (0x80000000 | (((entry << 6) >>> 0) & (mask >>> 1))) >>> 0;
        while (i < lend) {
          real = (realAddress + (i << 12) - start) & 0x1fffffff;
          this.core.memory.t[i] = real >>> 16;
          i++;
        }
      }
    };
    this.buildTLB = function(tlb, clear) {
      var highest, lowest, middle;
      //calculate the mapped address range that this TLB entry is mapping
      lowest = (tlb.entryHi & 0xffffff00) >>> 0; //Don't support ASID field
      middle = (lowest + tlb.loCompare) >>> 0;
      highest = (lowest + tlb.loCompare * 2) >>> 0;
      this.buildTLBHelper(lowest, middle, tlb.entryLo0, tlb.myHiMask, clear);
      this.buildTLBHelper(middle, highest, tlb.entryLo1, tlb.myHiMask, clear);
    };
    this.refreshTLB = function(tlb, cp0) {
      if (tlb.valid === 1) { //clear old tlb
        this.buildTLB(tlb, true);
      }
      this.writeTLBEntry(tlb, cp0);
      tlb.valid = 0;
      if ((cp0[consts.ENTRYLO1] & consts.TLBLO_V) || (cp0[consts.ENTRYLO0] & consts.TLBLO_V)) {
        tlb.valid = 1;
      }
      if (tlb.valid === 1) {
        this.buildTLB(tlb);
      }
    };
    this.inter_tlbwi = function(index, tlb, cp0) {
      if (index < 0 || index > 31) {
        console.log("ERROR: tlbwi received an invalid index=%08X", index);
        return;
      }
      this.refreshTLB(tlb[index], cp0);
    };
    this.inter_tlbp = function(tlb, cp0) {
      var idx;
      cp0[consts.INDEX] |= 0x80000000; //initially set high-order bit
      idx = 0;
      while (idx < 31) {
        if ((tlb[idx].entryHi & tlb[idx].myHiMask) === (cp0[consts.ENTRYHI] & tlb[idx].myHiMask)) {
          if ((tlb[idx].entryLo0 & consts.TLBLO_G & tlb[idx].entryLo1) || (tlb[idx].entryHi & consts.TLBHI_PIDMASK) === (cp0[consts.ENTRYHI] & consts.TLBHI_PIDMASK)) {
            cp0[consts.INDEX] = idx;
            break;
          }
        }
        idx++;
      }
    };
    this.inter_tlbr = function(tlb, cp0) {
      var index;
      index = cp0[consts.INDEX] & 0x7FFFFFFF;
      if (index < 0 || index > 31) {
        console.log("ERROR: tlbr received an invalid index=%08X", index);
        return;
      }
      cp0[consts.PAGEMASK] = tlb[index].pageMask;
      cp0[consts.ENTRYHI] = tlb[index].entryHi;
      cp0[consts.ENTRYHI] &= ~tlb[index].pageMask >>> 0;
      cp0[consts.ENTRYLO1] = tlb[index].entryLo1;
      cp0[consts.ENTRYLO0] = tlb[index].entryLo0;
    };
    return this;
  };

  //hack global space until we export classes properly
  //node.js uses exports; browser uses this (window)
  root = typeof exports !== "undefined" && exports !== null ? exports : self;

  root.C1964jsHelpers = C1964jsHelpers;

  //print out a hex number
  root.dec2hex = function(u) {
    "use strict";
    var d, h, hD;
    d = void 0;
    h = void 0;
    hD = "0123456789ABCDEF";
    d = u;
    h = hD.substr(d & 15, 1);
    while (true) {
      d >>= 4;
      d &= 0x0fffffff;
      h = hD.substr(d & 15, 1) + h;
      if (!(d > 15)) {
        break;
      }
    }
    return h;
  };

}).call(this);
