// Generated by CoffeeScript 2.5.1
(function() {
  /*1964js - JavaScript/HTML5 port of 1964 - N64 emulator
  Copyright (C) 2012 Joel Middendorf

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.*/
  //jslint devel: true
  //globals consts, C1964jsEmulator
  //console.log(message);
  "use strict";
  var C1964jsDmaLE, root;

  C1964jsDmaLE = class C1964jsDmaLE {
    constructor(memory, interrupts, pif) {
      this.startTime = 0;
      this.memory = memory;
      this.interrupts = interrupts;
      this.pif = pif;
      this.audio = void 0;
    }

    copyCartToDram(pc, isDelaySlot) {
      var end, from, remaining, to, transfer;
      end = this.memory.getInt32(this.memory.piUint8Array, consts.PI_WR_LEN_REG, this.memory.piUint32Array);
      to = this.memory.getInt32(this.memory.piUint8Array, consts.PI_DRAM_ADDR_REG, this.memory.piUint32Array);
      from = this.memory.getInt32(this.memory.piUint8Array, consts.PI_CART_ADDR_REG, this.memory.piUint32Array);
      log(dec2hex(pc) + ": pi dma write " + (end + 1) + " bytes from " + dec2hex(from) + " to " + dec2hex(to));
      end &= 0x00ffffff;
      to &= 0x00ffffff;
      transfer = end;
      remaining = -1;
      //end+1 is how many bytes will be copied.
      if ((from & 0x10000000) !== 0) {
        from &= 0x0fffffff;
        //the ROM buffer size could be less than the amount requested
        //because the file is not padded with zeros.
        if (from + end + 1 > this.memory.rom.byteLength) {
          transfer = this.memory.rom.byteLength - from - 1;
          remaining = end - transfer;
        }
        const d = this.memory.u8;
        const r = this.memory.romUint8Array;
        if (((to & 3) === 0) && ((from & 3) === 0)) {
          while (transfer >= 0) {
            d[to] = r[from];
            to++;
            from++;
            --transfer;
          }
        } else {
          while (transfer >= 0) {
            d[to ^ 3] = r[from ^ 3];
            to++;
            from++;
            --transfer;
          }
        }
      } else {
        //if (remaining !== -1)
        //    alert('doh!' + remaining);
        const d = this.memory.u8;
        while (end-- >= 0) {
          d[to ^ 3] = this.memory.lb(from);
          from++;
          to++;
        }
      }
      // clrFlag(spReg1Uint8Array, SP_STATUS_REG, SP_STATUS_HALT);
      this.interrupts.clrFlag(this.memory.piUint8Array, consts.PI_STATUS_REG, consts.PI_STATUS_IO_BUSY | consts.PI_STATUS_DMA_BUSY);
      this.interrupts.triggerPIInterrupt(pc, isDelaySlot);
    }

    copyDramToCart(pc, isDelaySlot) {
      return alert("copyDramToCart");
    }

    copySiToDram(pc, isDelaySlot) {
      var end, from, to;
      end = 63; //read 64 bytes. Is there an si_wr_len_reg?
      to = this.memory.getInt32(this.memory.siUint8Array, consts.SI_DRAM_ADDR_REG, this.memory.siUint32Array);
      from = this.memory.getInt32(this.memory.siUint8Array, consts.SI_PIF_ADDR_RD64B_REG, this.memory.siUint32Array);
      if (from !== 0x1FC007C0) {
        throw Error("Unhandled: SI_DRAM_ADDR_RD64B_REG = " + from);
      }
      log("si dma write " + (end + 1) + " bytes from " + dec2hex(from) + " to " + dec2hex(to));
      end &= 0x00ffffff;
      to &= 0x0fffffff;
      from &= 0x0000ffff;
      this.pif.processPif();
      while (end >= 0) {
        this.memory.u8[to ^ 3] = this.memory.pifUint8Array[from ^ 3];
        to++;
        from++;
        --end;
      }
      this.interrupts.setFlag(this.memory.siUint8Array, consts.SI_STATUS_REG, consts.SI_STATUS_INTERRUPT);
      this.interrupts.triggerSIInterrupt(pc, isDelaySlot);
    }

    copyDramToAi(pc, isDelaySlot) {
      var from, length;
      length = this.memory.getInt32(this.memory.aiUint8Array, consts.AI_LEN_REG, this.memory.aiUint32Array);
      from = this.memory.getInt32(this.memory.aiUint8Array, consts.AI_DRAM_ADDR_REG, this.memory.aiUint32Array);
      
      //log('ai dma write ' + length + ' bytes from ' + dec2hex(from));
      length &= 0x00ffffff;
      from &= 0x0fffffff;
      if (this.audio === undefined) {
        this.audio = new C1964jsAudio();
      }
      if (this.audio.processAudio(this.memory, from, length) === false) {
        this.interrupts.clrFlag(this.memory.aiUint8Array, consts.AI_STATUS_REG, consts.AI_STATUS_FIFO_FULL);
        this.interrupts.triggerAIInterrupt(0, false);
      } else {
        this.interrupts.setFlag(this.memory.aiUint8Array, consts.AI_STATUS_REG, consts.AI_STATUS_FIFO_FULL);
      }
    }

    copyDramToSi(pc, isDelaySlot) {
      var end, from, to;
      end = 63; //read 64 bytes. Is there an si_rd_len_reg?
      to = this.memory.getInt32(this.memory.siUint8Array, consts.SI_PIF_ADDR_WR64B_REG, this.memory.siUint32Array);
      from = this.memory.getInt32(this.memory.siUint8Array, consts.SI_DRAM_ADDR_REG, this.memory.siUint32Array);
      if (to !== 0x1FC007C0) {
        throw Error("Unhandled: SI_DRAM_ADDR_RD64B_REG = " + from);
      }
      log("si dma read " + (end + 1) + " bytes from " + dec2hex(from) + " to " + dec2hex(to));
      end &= 0x00ffffff;
      to &= 0x0000ffff;
      from &= 0x0fffffff;
      while (end >= 0) {
        this.memory.pifUint8Array[to ^ 3] = this.memory.u8[from ^ 3];
        to++;
        from++;
        --end;
      }
      //@pif.processPif()
      this.interrupts.setFlag(this.memory.siUint8Array, consts.SI_STATUS_REG, consts.SI_STATUS_INTERRUPT);
      this.interrupts.triggerSIInterrupt(pc, isDelaySlot);
    }

    copySpToDram(pc, isDelaySlot) {
      alert("todo: copySpToDram");
    }

    copyDramToSp(pc, isDelaySlot) {
      var end, from, to;
      end = this.memory.getInt32(this.memory.spReg1Uint8Array, consts.SP_RD_LEN_REG, this.memory.spReg1Uint32Array);
      to = this.memory.getInt32(this.memory.spReg1Uint8Array, consts.SP_MEM_ADDR_REG, this.memory.spReg1Uint32Array);
      from = this.memory.getInt32(this.memory.spReg1Uint8Array, consts.SP_DRAM_ADDR_REG, this.memory.spReg1Uint32Array);
      log("sp dma read " + (end + 1) + " bytes from " + dec2hex(from) + " to " + dec2hex(to));
      end &= 0x00000FFF;
      to &= 0x00001fff;
      from &= 0x00ffffff;
      if (((to & 3) === 0) && ((from & 3) === 0)) {
        while (end >= 0) {
          this.memory.spMemUint8Array[to] = this.memory.u8[from];
          to++;
          from++;
          --end;
        }
      } else {
        while (end >= 0) {
          this.memory.spMemUint8Array[to ^ 3] = this.memory.u8[from ^ 3];
          to++;
          from++;
          --end;
        }
      }
      this.memory.setInt32(this.memory.spReg1Uint8Array, consts.SP_DMA_BUSY_REG, 0, this.memory.spReg1Uint32Array);
      if (this.memory.getInt32(this.memory.spReg1Uint8Array, consts.SP_STATUS_REG, this.memory.spReg1Uint32Array) & (consts.SP_STATUS_DMA_BUSY | consts.SP_STATUS_IO_FULL | consts.SP_STATUS_DMA_FULL)) {
        alert("hmm..todo: an sp fp status flag is blocking from continuing");
      }
      this.interrupts.clrFlag(this.memory.spReg1Uint8Array, consts.SP_STATUS_REG, consts.SP_STATUS_DMA_BUSY);
      this.interrupts.setFlag(this.memory.spReg1Uint8Array, consts.SP_STATUS_REG, consts.SP_STATUS_HALT);
    }

  };

  //hack for now
  //triggerDPInterrupt(0, false);

  //hack global space until we export classes properly
  //node.js uses exports; browser uses this (window)
  root = typeof exports !== "undefined" && exports !== null ? exports : self;

  root.C1964jsDmaLE = C1964jsDmaLE;

  root.log = function(message) {
    "use strict";
  };

}).call(this);
