// Generated by CoffeeScript 2.5.1
(function() {
  /*1964js - JavaScript/HTML5 port of 1964 - N64 emulator
  Copyright (C) 2012 Joel Middendorf

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.*/
  //jslint todo: true, bitwise: true

  //globals window, mat4, C1964jsRenderer, consts, dec2hex, Float32Array
  "use strict";
  var C1964jsVideoHLE, root;

  C1964jsVideoHLE = class C1964jsVideoHLE {
    constructor(core, glx) {
      /**
       * Microcode 0 LUT
       * @type {!Array<!function(number)>}
       * @const
       */
      var i;
      this.ucode = -1;
      this.processDisplayList = this.callBind(this.processDisplayList, this);
      i = void 0;
      /**
       * @const
       */
      this.core = core; //only needed for gfxHelpers prototypes to access.
      /**
       * @const
       */
      this.gl = glx;
      this.fogIsImplemented = false; //enable this when we supoort fog
      
      //todo: make gRSP a class object.
      this.RICE_MATRIX_STACK = 60;
      this.MAX_TEXTURES = 8;
      this.MAX_VERTICES = 80;
      this.MAX_TILES = 8;
      this.tmem = new Uint8Array(1024 * 4);
      this.tlut = new Uint8Array(1024 * 4);
      this.activeTile = 0;
      this.textureTile = [];
      this.zDepthImage = {
        fmt: 0,
        siz: 0,
        width: 0,
        addr: 0
      };
      this.zColorImage = {
        fmt: 0,
        siz: 0,
        width: 0,
        addr: 0
      };
      /**
       * @const
       */
      this.N64VertexList = [];
      this.geometryMode = 0;
      /**
       * @const
       */
      this.gRSP = {};
      /**
       * @const
       */
      this.gRSPlights = [{}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}];
      /**
       * @const
       */
      this.gRSPn64lights = [{}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}];
      this.gRSPnumLights = 0;
      this.matToLoad = mat4.create();
      this.lightingMat = mat4.create();
      this.triangleVertexPositionBuffer = undefined;
      this.triangleVertexColorBuffer = undefined;
      this.dlistStackPointer = 0;
      this.dlistStack = [];
      if (core.isLittleEndian === 1 && core.useByteCompatibilityMode === false) {
        this.renderer = new C1964jsRendererLE(this.core.settings, this.core.webGL.gl, this.core.webGL);
      } else {
        this.renderer = new C1964jsRenderer(this.core.settings, this.core.webGL.gl, this.core.webGL);
      }
      this.texImg = {};
      this.segments = [];
      this.gl.useProgram(this.core.webGL.shaderProgram);
      /**
       * @const
       */
      this.primColor = [0.0, 0.0, 0.0, 0.0];
      /**
       * @const
       */
      this.fillColor = [0.0, 0.0, 0.0, 0.0];
      /**
       * @const
       */
      this.blendColor = [0.0, 0.0, 0.0, 0.0];
      /**
       * @const
       */
      this.envColor = [0.0, 0.0, 0.0, 0.0];
      /**
       * @const
       */
      this.triVertices = new Float32Array(16384);
      /**
       * @const
       */
      this.triColorVertices = new Uint8Array(16384);
      /**
       * @const
       */
      this.triTextureCoords = new Float32Array(16384);
      this.tempVec4 = new Float32Array(4);
      this.tempVec3Buffer = new ArrayBuffer(3 * this.MAX_VERTICES * 4);
      this.otherModeL = 0;
      this.otherModeH = 0;
      this.cycleType = 0;
      this.alphaTestEnabled = 0;
      this.bShade = false;
      this.bTextureGen = false;
      this.bLightingEnable = false;
      this.bFogEnable = false;
      this.bZBufferEnable = false;
      this.colorsTexture0 = this.gl.createTexture();
      this.colorsTexture1 = this.gl.createTexture();
      this.renderStateChanged = false;
      this.inverseTransposeCalculated = false;
      /**
       * @const
       */
      this.normalMat = new Float32Array(4);
      /**
       * @const
       */
      this.modelViewInverse = mat4.create();
      /**
       * @const
       */
      this.modelViewTransposedInverse = mat4.create();
      // Native Viewport
      this.n64ViewportWidth = 640;
      this.n64ViewportHeight = 480;
      this.n64ViewportLeft = 0;
      this.n64ViewportTop = 0;
      this.n64ViewportRight = 320;
      this.n64ViewportBottom = 240;
      i = 0;
      while (i < this.MAX_TILES) {
        this.textureTile[i] = [];
        i += 1;
      }
      i = 0;
      while (i < this.MAX_VERTICES) {
        this.N64VertexList[i] = {};
        i += 1;
      }
      i = 0;
      while (i < consts.MAX_DL_STACK_SIZE) {
        this.dlistStack[i] = {};
        i += 1;
      }
      i = 0;
      while (i < this.segments.length) {
        this.segments[i] = 0;
        i += 1;
      }
      this.gRSP.projectionMtxs = [];
      this.gRSP.modelviewMtxs = [];
      this.gRSP.ambientLightIndex = 0;
      this.gRSP.ambientLightColor = 0;
      this.gRSP.fAmbientLightA = 0;
      this.gRSP.fAmbientLightR = 0;
      this.gRSP.fAmbientLightG = 0;
      this.gRSP.fAmbientLightB = 0;
      this.gl.clearColor(0.0, 0.0, 0.0, 0.0);
      this.gl.depthFunc(this.gl.LEQUAL);
      this.gl.clearDepth(1.0);
      this.gl.disable(this.gl.DEPTH_TEST);
      //todo: allocate on-demand
      i = 0;
      while (i < this.RICE_MATRIX_STACK) {
        this.gRSP.projectionMtxs[i] = mat4.create();
        this.gRSP.modelviewMtxs[i] = mat4.create();
        i += 1;
      }
      this.triangleVertexTextureCoordBuffer = undefined;
      this.resetMatrices();
      this.combine = new Uint32Array(16);
      this.makeUcodeData();
      this.makeUcodeMap();
      this.crcTable = this.makeCRCTable();
      this.vertexMult = 0;
      this.vertexMultVals = [
        10, // ucode 0 - Mario
        2, // ucode 1 - GBI1
        10, // ucode 2 - Golden Eye
        2, // ucode 3 - S2DEX GBI2
        5, // ucode 4 - Wave Racer
        2, // ucode 5 - BGI2
        10, // ucode 6 - DKR
        2, // ucode 7 - S2DEX
        10, // ucode 8 - ucode 0 with sprite2D, for Demo Puzzle Master 64
        10, // ucode 9 - Perfect Dark
        2, // ucode 10 - Conker
        10, // ucode 11 - Gemini
        2, // ucode 12 - Silicon Valley, Spacestation
        2, // ucode 13 - modified ucode S2DEX
        2, // ucode 14 - OgreBattle Background
        10, // ucode 15 - ucode 0 with sprite2D
        5, // ucode 16 - Star War, Shadow of Empire
        2, // ucode 17 - Star Wars - Rogue Squadron, 
        2, // ucode 18 - World Driver Championship, check me here
        2, // ucode 19 - Last Legion UX, check me here
        2 // ucode 20 - ZSortp
      ];
      return;
    }

    makeUcodeMap() {
      this.microcodeMap0 = [this.RSP_GBI1_SpNoop, this.RSP_GBI0_Mtx, this.RSP_GBI1_Reserved, this.RSP_GBI1_MoveMem, this.RSP_GBI0_Vtx, this.RSP_GBI1_Reserved, this.RSP_GBI0_DL, this.RSP_GBI1_Reserved, this.RSP_GBI1_Reserved, this.RSP_GBI0_Sprite2DBase, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_GBI0_Tri4, this.RSP_GBI1_RDPHalf_Cont, this.RSP_GBI1_RDPHalf_2, this.RSP_GBI1_RDPHalf_1, this.RSP_GBI1_Line3D, this.RSP_GBI1_ClearGeometryMode, this.RSP_GBI1_SetGeometryMode, this.RSP_GBI1_EndDL, this.RSP_GBI1_SetOtherModeL, this.RSP_GBI1_SetOtherModeH, this.RSP_GBI1_Texture, this.RSP_GBI1_MoveWord, this.RSP_GBI1_PopMtx, this.RSP_GBI1_CullDL, this.RSP_GBI1_Tri1, this.RSP_GBI1_Noop, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RDP_TriFill, this.RDP_TriFillZ, this.RDP_TriTxtr, this.RDP_TriTxtrZ, this.RDP_TriShade, this.RDP_TriShadeZ, this.RDP_TriShadeTxtr, this.RDP_TriShadeTxtrZ, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.RSP_RDP_Nothing, this.DLParser_TexRect, this.DLParser_TexRectFlip, this.DLParser_RDPLoadSynch, this.DLParser_RDPPipeSynch, this.DLParser_RDPTileSynch, this.DLParser_RDPFullSynch, this.DLParser_SetKeyGB, this.DLParser_SetKeyR, this.DLParser_SetConvert, this.DLParser_SetScissor, this.DLParser_SetPrimDepth, this.DLParser_RDPSetOtherMode, this.DLParser_LoadTLut, this.RSP_RDP_Nothing, this.DLParser_SetTileSize, this.DLParser_LoadBlock, this.DLParser_LoadTile, this.DLParser_SetTile, this.DLParser_FillRect, this.DLParser_SetFillColor, this.DLParser_SetFogColor, this.DLParser_SetBlendColor, this.DLParser_SetPrimColor, this.DLParser_SetEnvColor, this.DLParser_SetCombine, this.DLParser_SetTImg, this.DLParser_SetZImg, this.DLParser_SetCImg];
    }

    makeUcodeData() {
      return this.ucodeData = [
        [
          //ucode, crc_size, crc_800, ucode_name, non_nearclip, reject
          0,
          0x150c3ce8,
          0x150c3ce8,
          "RSP SW Version: 2.0D, 04-01-96" // Super Mario 64
        ],
        [
          4,
          0x2b94276f,
          0x2b94276f,
          "RSP SW Version: 2.0D, 04-01-96" // Wave Race 64 (v1.0)
        ],
        [
          16,
          0xb1870454,
          0xb1870454,
          "RSP SW Version: 2.0D, 04-01-96" // Star Wars - Shadows of the Empire (v1.0),
        ],
        [
          0,
          0x51671ae4,
          0x51671ae4,
          "RSP SW Version: 2.0D, 04-01-96" // Pilot Wings 64,
        ],
        [
          0,
          0x67b5ac55,
          0x67b5ac55,
          "RSP SW Version: 2.0D, 04-01-96" // Wibble,
        ],
        [
          0,
          0x64dc8104,
          0x64dc8104,
          "RSP SW Version: 2.0D, 04-01-96" // Dark Rift,
        ],
        [
          0,
          0x309f363d,
          0x309f363d,
          "RSP SW Version: 2.0D, 04-01-96" // Killer Instinct Gold,
        ],
        [
          0,
          0xfcb57e57,
          0xfcb57e57,
          "RSP SW Version: 2.0D, 04-01-96" // Blast Corps,
        ],
        [
          0,
          0xb420f35a,
          0xb420f35a,
          "RSP SW Version: 2.0D, 04-01-96" // Blast Corps,
        ],
        [0,
        0x6e26c1df,
        0x7c98e9c2,
        "RSP SW Version: 2.0D, 04-01-96"],
        [
          2,
          0xc02ac7bc,
          0xc02ac7bc,
          "RSP SW Version: 2.0G, 09-30-96" // GoldenEye 007,
        ],
        [
          0,
          0xe5fee3bc,
          0xe5fee3bc,
          "RSP SW Version: 2.0G, 09-30-96" // Aero Fighters Assault,
        ],
        [
          8,
          0xe4bb5ad8,
          0x80129845,
          "RSP SW Version: 2.0G, 09-30-96" // Puzzle Master 64,
        ],
        [
          0,
          0x72109ec6,
          0x72109ec6,
          "RSP SW Version: 2.0H, 02-12-97" // Duke Nukem 64,
        ],
        [
          0,
          0xf24a9a04,
          0xf24a9a04,
          "RSP SW Version: 2.0H, 02-12-97" // Tetrisphere,
        ],
        [
          15,
          0x700de42e,
          0x700de42e,
          "RSP SW Version: 2.0H, 02-12-97" // Wipeout 64 (uses GBI1 too!),
        ],
        [
          15,
          0x1b304a74,
          0x1b304a74,
          "RSP SW Version: 2.0H, 02-12-97" // Flying Dragon,
        ],
        [
          15,
          0xe4bb5ad8,
          0xa7b2f704,
          "RSP SW Version: 2.0H, 02-12-97" // Silicon Valley,
        ],
        [
          15,
          0xe4bb5ad8,
          0x88202781,
          "RSP SW Version: 2.0H, 02-12-97" // Glover,
        ],
        [
          0,
          0xe466b5bd,
          0xe466b5bd,
          "Unknown 0xe466b5bd, 0xe466b5bd" // Dark Rift,
        ],
        [
          9,
          0x7064a163,
          0x7064a163,
          "Unknown 0x7064a163, 0x7064a163" // Perfect Dark (v1.0),
        ],
        [
          0,
          0x6522df69,
          0x71bd078d,
          "Unknown 0x6522df69, 0x71bd078d" // Tetris
        ],
        [
          0,
          0x6522df69,
          0x1b0c23a8,
          "Unknown 0x6522df69, 0x1b0c23a8" // Pachinko Nichi
        ],
        [
          // GBI1
          1,
          0x45ca328e,
          0x45ca328e,
          "RSP Gfx ucode F3DLX 0.95 Yoshitaka Yasumoto Nintendo." // Mario Kart 64,
        ],
        [
          1,
          0x98e3b909,
          0x98e3b909,
          "RSP Gfx ucode F3DEX 0.95 Yoshitaka Yasumoto Nintendo." // Mario Kart 64
        ],
        [
          1,
          0x5d446090,
          0x5d446090,
          "RSP Gfx ucode F3DLP.Rej 0.96 Yoshitaka Yasumoto Nintendo.",
          0,
          1 // Jikkyou J. League Perfect Striker,
        ],
        [
          1,
          0x244f5ca3,
          0x244f5ca3,
          "RSP Gfx ucode F3DEX 1.00 Yoshitaka Yasumoto Nintendo." // F-1 Pole Position 64,
        ],
        [
          1,
          0x6a022585,
          0x6a022585,
          "RSP Gfx ucode F3DEX.NoN 1.00 Yoshitaka Yasumoto Nintendo.",
          1 // Turok - The Dinosaur Hunter (v1.0),
        ],
        [
          1,
          0x150706be,
          0x150706be,
          "RSP Gfx ucode F3DLX.NoN 1.00 Yoshitaka Yasumoto Nintendo.",
          1 // Extreme-G,
        ],
        [
          1,
          0x503f2c53,
          0x503f2c53,
          "RSP Gfx ucode F3DEX.NoN 1.21 Yoshitaka Yasumoto Nintendo.",
          1 // Bomberman 64,
        ],
        [
          1,
          0xc705c37c,
          0xc705c37c,
          "RSP Gfx ucode F3DLX 1.21 Yoshitaka Yasumoto Nintendo." // Fighting Force 64, Wipeout 64
        ],
        [
          1,
          0xa2146075,
          0xa2146075,
          "RSP Gfx ucode F3DLX.NoN 1.21 Yoshitaka Yasumoto Nintendo.",
          1 // San Francisco Rush - Extreme Racing,
        ],
        [
          1,
          0xb65aa2da,
          0xb65aa2da,
          "RSP Gfx ucode L3DEX 1.21 Yoshitaka Yasumoto Nintendo." // Wipeout 64,
        ],
        [
          1,
          0x0c8e5ec9,
          0x0c8e5ec9,
          "RSP Gfx ucode F3DEX 1.21 Yoshitaka Yasumoto Nintendo." 
        ],
        [1,
        0xe30795f2,
        0xa53df3c4,
        "RSP Gfx ucode F3DLP.Rej 1.21 Yoshitaka Yasumoto Nintendo.",
        0,
        1],
        [
          1,
          0xaebeda7d,
          0xaebeda7d,
          "RSP Gfx ucode F3DLX.Rej 1.21 Yoshitaka Yasumoto Nintendo.",
          0,
          1 // Jikkyou World Soccer 3,
        ],
        [
          1,
          0x0c8e5ec9,
          0x0c8e5ec9,
          "RSP Gfx ucode F3DEX 1.23 Yoshitaka Yasumoto Nintendo" // Wave Race 64 (Rev. 2) - Shindou Rumble Edition (JAP)
        ],
        [
          1,
          0xc705c37c,
          0xc705c37c,
          "RSP Gfx ucode F3DLX 1.23 Yoshitaka Yasumoto Nintendo." // GT
        ],
        [
          1,
          0x2a61350d,
          0x2a61350d,
          "RSP Gfx ucode F3DLX 1.23 Yoshitaka Yasumoto Nintendo." // Toy Story2
        ],
        [
          1,
          0x0c8e5ec9,
          0x0c8e5ec9,
          "RSP Gfx ucode F3DEX 1.23 Yoshitaka Yasumoto Nintendo." // Wave Race 64 Shindou Edition
        ],
        [
          12,
          0xfc6529aa,
          0xfc6529aa,
          "RSP Gfx ucode F3DEX 1.23 Yoshitaka Yasumoto Nintendo." // Superman - The Animated Series,
        ],
        [
          1,
          0xa56cf996,
          0xa56cf996,
          "RSP Gfx ucode L3DEX 1.23 Yoshitaka Yasumoto Nintendo." // Flying Dragon,
        ],
        [
          1,
          0xcc83b43f,
          0xcc83b43f,
          "RSP Gfx ucode F3DEX.NoN 1.23 Yoshitaka Yasumoto Nintendo.",
          1 // AeroGauge,
        ],
        [
          1,
          0xca8927a0,
          0xca8927a0,
          "RSP Gfx ucode F3DLX.Rej 1.23 Yoshitaka Yasumoto Nintendo.",
          0,
          1 // Puzzle Bobble 64,
        ],
        [1,
        0x25689c75,
        0xbe481ae8,
        "RSP Gfx ucode F3DLP.Rej 1.23 Yoshitaka Yasumoto Nintendo.",
        0,
        1],
        [
          1,
          0xd2d747b7,
          0xd2d747b7,
          "RSP Gfx ucode F3DLX.NoN 1.23 Yoshitaka Yasumoto Nintendo.",
          1 // Penny Racers,
        ],
        [
          1,
          0xa849c858,
          0x5bd32b5a,
          "RSP Gfx ucode F3DTEX/A 1.23 Yoshitaka Yasumoto Nintendo." // Tamagotchi
        ],
        [
          7,
          0xecd8b772,
          0xecd8b772,
          "RSP Gfx ucode S2DEX 1.06 Yoshitaka Yasumoto Nintendo." // Yoshi's Story,
        ],
        [
          7,
          0xf59132f5,
          0xf59132f5,
          "RSP Gfx ucode S2DEX 1.07 Yoshitaka Yasumoto Nintendo." // Bakuretsu Muteki Bangaioh,
        ],
        [
          7,
          0x961dd811,
          0x961dd811,
          "RSP Gfx ucode S2DEX 1.03 Yoshitaka Yasumoto Nintendo." // GT
        ],
        [
          5,
          0x3e083afa,
          0x722f97cc,
          "RSP Gfx ucode F3DEX.NoN fifo 2.03 Yoshitaka Yasumoto 1998 Nintendo.",
          1 // F-Zero X,
        ],
        [
          5,
          0xa8050bd1,
          0xa8050bd1,
          "RSP Gfx ucode F3DEX fifo 2.03 Yoshitaka Yasumoto 1998 Nintendo." // F-Zero X,
        ],
        [
          5,
          0x4e8055f0,
          0x4e8055f0,
          "RSP Gfx ucode F3DLX.Rej fifo 2.03 Yoshitaka Yasumoto 1998 Nintendo.",
          0,
          1 // F-Zero X,
        ],
        [
          5,
          0xabf001f5,
          0xabf001f5,
          "RSP Gfx ucode F3DFLX.Rej fifo 2.03F Yoshitaka Yasumoto 1998 Nintendo.",
          0,
          1 // F-Zero X,
        ],
        [
          5,
          0xadb4b686,
          0xadb4b686,
          "RSP Gfx ucode F3DEX fifo 2.04 Yoshitaka Yasumoto 1998 Nintendo." // Top Gear Rally 2,
        ],
        [
          5,
          0x779e2a9b,
          0x779e2a9b,
          "RSP Gfx ucode F3DEX.NoN fifo 2.04 Yoshitaka Yasumoto 1998 Nintendo.",
          1 // California Speed,
        ],
        [
          5,
          0xa8cb3e09,
          0xa8cb3e09,
          "RSP Gfx ucode L3DEX fifo 2.04 Yoshitaka Yasumoto 1998 Nintendo." // In-Fisherman Bass Hunter 64,
        ],
        [
          5,
          0x2a1341d6,
          0x2a1341d6,
          "RSP Gfx ucode F3DEX fifo 2.04H Yoshitaka Yasumoto 1998 Nintendo." // Kirby 64 - The Crystal Shards,
        ],
        [
          5,
          0x3e083afa,
          0x89a8e0ed,
          "RSP Gfx ucode F3DEX.NoN fifo 2.05 Yoshitaka Yasumoto 1998 Nintendo.",
          1 // Carmageddon 64 (uncensored),
        ],
        [5,
        0x4964b75d,
        0x4964b75d,
        "RSP Gfx ucode F3DEX.NoN fifo 2.05 Yoshitaka Yasumoto 1998 Nintendo.",
        1],
        [
          5,
          0x39e3e95a,
          0x39e3e95a,
          "RSP Gfx ucode F3DEX fifo 2.05 Yoshitaka Yasumoto 1998 Nintendo." // Knife Edge - Nose Gunner,
        ],
        [
          5,
          0xd2913522,
          0xd2913522,
          "RSP Gfx ucode F3DAM fifo 2.05 Yoshitaka Yasumoto 1998 Nintendo." // Hey You, Pikachu!,
        ],
        [
          5,
          0x3e083afa,
          0xc998443f,
          "RSP Gfx ucode F3DEX xbus 2.05 Yoshitaka Yasumoto 1998 Nintendo." //Triple play
        ],
        [
          5,
          0xf4184a7d,
          0xf4184a7d,
          "RSP Gfx ucode F3DEX fifo 2.06 Yoshitaka Yasumoto 1998 Nintendo." // Hey You, Pikachu!,
        ],
        [
          5,
          0x595a88de,
          0x595a88de,
          "RSP Gfx ucode F3DEX.Rej fifo 2.06 Yoshitaka Yasumoto 1998 Nintendo.",
          0,
          1 // Bio Hazard 2,
        ],
        [
          5,
          0x0259f764,
          0x0259f764,
          "RSP Gfx ucode F3DLX.Rej fifo 2.06 Yoshitaka Yasumoto 1998 Nintendo.",
          0,
          1 // Mario Party,
        ],
        [
          5,
          0xe1a5477a,
          0xe1a5477a,
          "RSP Gfx ucode F3DEX.NoN xbus 2.06 Yoshitaka Yasumoto 1998 Nintendo.",
          1 // Command & Conquer,
        ],
        [
          5,
          0x4cfa0a19,
          0x4cfa0a19,
          "RSP Gfx ucode F3DZEX.NoN fifo 2.06H Yoshitaka Yasumoto 1998 Nintendo.",
          1 // The Legend of Zelda - Ocarina of Time (v1.0),
        ],
        [5,
        0x2cbd9514,
        0x5f40b9f5,
        "RSP Gfx ucode F3DZEX.NoN fifo 2.06H Yoshitaka Yasumoto 1998 Nintendo.",
        1],
        [
          5,
          0x3e083afa,
          0x882680f4,
          "RSP Gfx ucode L3DEX fifo 2.07 Yoshitaka Yasumoto 1998 Nintendo." // Polaris Sno
        ],
        [
          5,
          0xdeb1cac0,
          0xdeb1cac0,
          "RSP Gfx ucode F3DEX.NoN fifo 2.07 Yoshitaka Yasumoto 1998 Nintendo.",
          1 // Knockout Kings 2000,
        ],
        [
          5,
          0xf4184a7d,
          0xf4184a7d,
          "RSP Gfx ucode F3DEX fifo 2.07 Yoshitaka Yasumoto 1998 Nintendo." // Xena Warrior Princess - Talisman of Fate, Army Men - Air Combat, Destruction Derby
        ],
        [
          5,
          0x4b013e60,
          0x4b013e60,
          "RSP Gfx ucode F3DEX xbus 2.07 Yoshitaka Yasumoto 1998 Nintendo." // Lode Runner 3-D,
        ],
        [
          5,
          0xd1a63836,
          0xd1a63836,
          "RSP Gfx ucode L3DEX fifo 2.08 Yoshitaka Yasumoto 1999 Nintendo." // Hey You, Pikachu!,
        ],
        [
          5,
          0x97193667,
          0x97193667,
          "RSP Gfx ucode F3DEX fifo 2.08 Yoshitaka Yasumoto 1999 Nintendo." // Top Gear Hyper-Bike,
        ],
        [
          5,
          0x92149ba8,
          0x92149ba8,
          "RSP Gfx ucode F3DEX fifo 2.08 Yoshitaka Yasumoto/Kawasedo 1999." // Paper Mario,
        ],
        [
          5,
          0xae0fb88f,
          0xae0fb88f,
          "RSP Gfx ucode F3DEX xbus 2.08 Yoshitaka Yasumoto 1999 Nintendo." // WWF WrestleMania 2000,
        ],
        [
          5,
          0xc572f368,
          0xc572f368,
          "RSP Gfx ucode F3DLX.Rej xbus 2.08 Yoshitaka Yasumoto 1999 Nintendo." // WWF No Mercy,
        ],
        [5,
        0x3e083afa,
        0x74252492,
        "RSP Gfx ucode F3DEX.NoN xbus 2.08 Yoshitaka Yasumoto 1999 Nintendo.",
        1],
        [
          5,
          0x9c2edb70,
          0xea98e740,
          "RSP Gfx ucode F3DEX.NoN fifo 2.08 Yoshitaka Yasumoto 1999 Nintendo.",
          1 // LEGO Racers,
        ],
        [
          5,
          0x79e004a6,
          0x79e004a6,
          "RSP Gfx ucode F3DLX.Rej fifo 2.08 Yoshitaka Yasumoto 1999 Nintendo.",
          0,
          1 // Mario Party 2,
        ],
        [
          5,
          0xaa6ab3ca,
          0xaa6ab3ca,
          "RSP Gfx ucode F3DEX.Rej fifo 2.08 Yoshitaka Yasumoto 1999 Nintendo.",
          0,
          1 // V-Rally Edition 99,
        ],
        [
          5,
          0x2c597e0f,
          0x2c597e0f,
          "RSP Gfx ucode F3DEX fifo 2.08 Yoshitaka Yasumoto 1999 Nintendo." // Cruis'n Exotica,
        ],
        [
          10,
          0x4e5f3e3b,
          0x4e5f3e3b,
          "RSP Gfx ucode F3DEXBG.NoN fifo 2.08 Yoshitaka Yasumoto 1999 Nintendo.",
          1 // Conker The Bad Fur Day
        ],
        [
          5,
          0x61f31862,
          0x61f31862,
          "RSP Gfx ucode F3DEX.NoN fifo 2.08H Yoshitaka Yasumoto 1999 Nintendo.",
          1 // Pokemon Snap,
        ],
        [
          5,
          0x005f5b71,
          0x005f5b71,
          "RSP Gfx ucode F3DZEX.NoN fifo 2.08I Yoshitaka Yasumoto/Kawasedo 1999.",
          1 // The Legend of Zelda 2 - Majora's Mask,
        ],
        [
          3,
          0x41839d1e,
          0x41839d1e,
          "RSP Gfx ucode S2DEX fifo 2.05 Yoshitaka Yasumoto 1998 Nintendo." // Chou Snobow Kids,
        ],
        [3,
        0x2cbd9514,
        0xc639dbb9,
        "RSP Gfx ucode S2DEX xbus 2.06 Yoshitaka Yasumoto 1998 Nintendo."],
        [
          3,
          0xec89e273,
          0xec89e273,
          "RSP Gfx ucode S2DEX fifo 2.08 Yoshitaka Yasumoto 1999 Nintendo." // V-Rally Edition 99,
        ],
        [
          3,
          0x9429b7d6,
          0x9429b7d6,
          "RSP Gfx ucode S2DEX xbus 2.08 Yoshitaka Yasumoto 1999 Nintendo." // Star Craft,
        ],
        [
          // {14,0x5a72397b, 0xec89e273, "RSP Gfx ucode S2DEX fifo 2.08 Yoshitaka Yasumoto 1999 Nintendo."], # OgreBattle Background,
          3,
          0x2cbd9514,
          0xec89e273,
          "RSP Gfx ucode S2DEX fifo 2.08 Yoshitaka Yasumoto 1999 Nintendo." // Zelda MM,
        ],
        [
          6,
          0x6aef74f8,
          0x6aef74f8,
          "Unknown 0x6aef74f8, 0x6aef74f8" // Diddy Kong Racing (v1.0),
        ],
        [
          6,
          0x4c4eead8,
          0x4c4eead8,
          "Unknown 0x4c4eead8, 0x4c4eead8" // Diddy Kong Racing (v1.1),
        ],
        [
          1,
          0xed421e9a,
          0xed421e9a,
          "Unknown 0xed421e9a, 0xed421e9a" // Kuiki Uhabi Suigo,
        ],
        [
          5,
          0x37751932,
          0x55c0fd25,
          "Unknown 0x37751932, 0x55c0fd25" // Bio Hazard 2,
        ],
        [
          11,
          0xbe0b83e7,
          0xbe0b83e7,
          "Unknown 0xbe0b83e7, 0xbe0b83e7" // Jet Force Gemini,
        ],
        [
          17,
          0x02e882cf,
          0x2ad17281,
          "Unknown 0x02e882cf, 0x2ad17281" // Indiana Jones,
        ],
        [
          17,
          0x1f7d9118,
          0xdab2199b,
          "Unknown 0x1f7d9118, 0xdab2199b" // Battle Naboo,
        ],
        [
          17,
          0x74583614,
          0x74583614,
          "Unknown 0x74583614, 0x74583614" // Star Wars - Rogue Squadron,
        ],
        [
          17,
          0xe37e2f49,
          0x1eb63fd8,
          "Unknown 0xe37e2f49, 0x1eb63fd8" // Star Wars - Rogue Squadron,
        ],
        [
          17,
          0x8ce1af3d,
          0xb2760ea2,
          "Unknown 0x8ce1af3d, 0xb2760ea2" // Star Wars - Rogue Squadron,
        ],
        [
          18,
          0x7b685972,
          0x57b8095a,
          "Unknown 0x7b685972, 0x57b8095a" // World Driver Championship
        ],
        [
          18,
          0xe92dbb9b,
          0x57b8095a,
          "Unknown 0xe92dbb9b, 0x57b8095a" // World Driver Championship
        ],
        [
          18,
          0xe6c9acc1,
          0x65f80845,
          "Unknown 0xe6c9acc1, 0x65f80845" // World Driver Championship
        ],
        [
          18,
          0x6522df69,
          0x720b88a0,
          "Unknown 0x6522df69, 0x720b88a0" // World Driver Championship
        ],
        [
          18,
          0x6522df69,
          0xf1e8ba9e,
          "Unknown 0x6522df69, 0xf1e8ba9e" // World Driver Championship
        ],
        [
          19,
          0xa486bed3,
          0xa486bed3,
          "Unknown 0xa486bed3, 0xa486bed3" // Last Legion UX,
        ],
        [
          19,
          0x6b519381,
          0xfebacfd8,
          "Unknown in Toukan Road" // I don't know which ucode
        ],
        [
          20,
          0x6d2a01b1,
          0x6d2a01b1,
          "RSP Gfx ucode ZSortp 0.33 Yoshitaka Yasumoto Nintendo." // Mia Hamm Soccer 64,
        ]
      ];
    }

    makeCRCTable() {
      var c, crcTable, k, m, n, p, poly, q, ref, u;
      crcTable = [];
      // terms of polynomial defining this crc (except x^32):
      p = [0, 1, 2, 4, 5, 7, 8, 10, 11, 12, 16, 22, 23, 26];
      // make exclusive-or pattern from polynomial (0xedb88320L)
      poly = 0; // polynomial exclusive-or pattern
      for (n = m = 0, ref = p.length; (0 <= ref ? m < ref : m > ref); n = 0 <= ref ? ++m : --m) {
        poly |= 1 << (31 - p[n]);
      }
      c = 0;
      for (n = q = 0; q < 256; n = ++q) {
        c = n;
        for (k = u = 0; u < 8; k = ++u) {
          if (c & 1) {
            c = (poly ^ (c >>> 1)) >>> 0;
          } else {
            c >>>= 1;
          }
        }
        crcTable[n] = c;
      }
      return crcTable;
    }

    computeCRC32(crc, base, len) {
      crc ^= 0xffffffff;
      crc >>>= 0;
      // the crcs hat 1964 made were based on little-endian memory layout, so 
      // for big endian and byteCompatibility mode, we need to ^3 to each byte.
      if (this.core.useByteCompatibilityMode === true || this.core.isLittleEndian === 0) {
        while (len > 0) {
          crc = (this.crcTable[(crc ^ this.core.memory.u8[base ^ 3]) & 0xff] ^ (crc >>> 8)) >>> 0;
          base++;
          len--;
        }
      } else {
        while (len > 0) {
          crc = (this.crcTable[(crc ^ this.core.memory.u8[base]) & 0xff] ^ (crc >>> 8)) >>> 0;
          base++;
          len--;
        }
      }
      return (crc ^ 0xffffffff) >>> 0;
    }

    DLParser_CheckUCode(start, dStart, size, dSize) {
      var base, crc800, crcSize, i, m, ref, str, ucode;
      ucode = -1;
      base = dStart & 0x1fffffff;
      str = "";
      if (base < this.core.currentRdramSize + 0x1000) {
        for (i = m = 0, ref = 0x1000 - 2; (0 <= ref ? m < ref : m > ref); i = 0 <= ref ? ++m : --m) {
          // check for 'R' 'S' 'P' ("RSP") ascii 82, 83, 80
          if (this.core.memory.readRdram8(base + i) === 82 && this.core.memory.readRdram8(base + i + 1) === 83 && this.core.memory.readRdram8(base + i + 2) === 80) {
            //concat chars (32 is ascii for space character)
            while (this.core.memory.readRdram8(base + i) >= 32) {
              str += String.fromCharCode(this.core.memory.readRdram8(base + i));
              i++;
            }
            crcSize = this.computeCRC32(0, start, 8);
            crc800 = this.computeCRC32(0, start, 0x800);
            ucode = this.DLParser_IdentifyUcode(crc800);
            break;
          }
        }
      }
      if (ucode !== -1) {
        console.log("Detected microcode " + ucode);
      } else {
        console.log("Unknown ucode. Using microcode #5");
        ucode = 5;
      }
      return ucode;
    }

    RDP_SetUcodeMap(ucode) {
      switch (ucode) {
        case 1:
          this.microcodeMap0[4] = this.RSP_GBI1_Vtx;
          this.microcodeMap0[9] = this.RSP_GBI1_Sprite2DBase;
          this.microcodeMap0[0xaf] = this.RSP_GBI1_LoadUCode;
          this.microcodeMap0[0xb0] = this.RSP_GBI1_BranchZ;
          this.microcodeMap0[0xb1] = this.RSP_GBI1_Tri2;
          this.microcodeMap0[0xb2] = this.RSP_GBI1_ModifyVtx;
          this.microcodeMap0[0xc1] = this.RSP_S2DEX_SPObjLoadTxtr_Ucode1;
      }
    }

    DLParser_IdentifyUcode(crc800) {
      var i, m, ref;
      for (i = m = 0, ref = this.ucodeData.length; (0 <= ref ? m < ref : m > ref); i = 0 <= ref ? ++m : --m) {
        //get crc_800 field
        if (this.ucodeData[i][2] === crc800) {
          //return ucode field
          return this.ucodeData[i][0];
        }
      }
      return -1; // not found
    }

    callBind(fn, me) {
      return function() {
        return fn.call(me);
      };
    }

    processDisplayList() {
      var wireframe;
      if (this.core.showFB === true) {
        this.initBuffers();
        this.core.webGL.show3D();
        this.core.showFB = false;
        this.resetState();
      }
      wireframe = document.getElementById("wireframe");
      this.core.settings.wireframe = false;
      if (wireframe !== null && wireframe.checked) {
        this.core.settings.wireframe = true;
      }
      this.core.webGL.beginDList();
      this.dlParserProcess();
      //this.core.interrupts.triggerDPInterrupt(0, false);
      this.core.interrupts.delayNextInterrupt = true; //don't process immediately
      this.core.interrupts.triggerDPInterrupt(0, false);
    }

    videoLog(msg) {}

    //console.log msg
    checkUcode() {
      var tUcode, tUcodeData, tUcodeDataSize, tUcodeSize;
      if (this.currentMicrocodeMap === void 0) {
        tUcode = this.core.memory.getInt32(this.core.memory.spMemUint8Array, consts.TASK_MICROCODE, this.core.memory.spMemUint32Array);
        tUcodeData = this.core.memory.getInt32(this.core.memory.spMemUint8Array, consts.TASK_MICROCODE_DATA, this.core.memory.spMemUint32Array);
        tUcodeSize = this.core.memory.getInt32(this.core.memory.spMemUint8Array, consts.TASK_MICROCODE_SIZE, this.core.memory.spMemUint32Array);
        tUcodeDataSize = this.core.memory.getInt32(this.core.memory.spMemUint8Array, consts.TASK_MICROCODE_DATA_SIZE, this.core.memory.spMemUint32Array);
        this.ucode = this.DLParser_CheckUCode(tUcode, tUcodeData, tUcodeSize, tUcodeDataSize);
        this.RDP_SetUcodeMap(this.ucode);
        this.vertexMult = 1.0 / this.vertexMultVals[this.ucode];
        this.currentMicrocodeMap = this.microcodeMap0; // to only execute this once
      }
    }

    dlParserProcess() {
      var aa, cmd, func, pc;
      this.checkUcode();
      this.dlistStackPointer = 0;
      this.dlistStack[this.dlistStackPointer].pc = this.core.memory.getInt32(this.core.memory.spMemUint8Array, consts.TASK_DATA_PTR, this.core.memory.spMemUint32Array) >>> 0;
      this.dlistStack[this.dlistStackPointer].countdown = consts.MAX_DL_COUNT;
      //see RSP_Parser.cpp
      //TODO: purge old textures
      //TODO: stats
      //TODO: force screen clear
      //TODO: set vi scales
      this.renderReset();
      //TODO: render reset
      //TODO: begin rendering
      //TODO: set viewport
      //TODO: set fill mode
      aa = 10000;
      while (this.dlistStackPointer >= 0 && aa > 0) {
        aa--;
        pc = this.dlistStack[this.dlistStackPointer].pc;
        cmd = this.getCommand(pc);
        func = this.currentMicrocodeMap[cmd];
        this.dlistStack[this.dlistStackPointer].pc += 8;
        func.call(this, pc);
        if (this.dlistStackPointer >= 0) {
          this.dlistStack[this.dlistStackPointer].countdown -= 1;
          if (this.dlistStack[this.dlistStackPointer].countdown < 0) {
            this.dlistStackPointer -= 1;
          }
        }
      }
      if (aa <= 0) {
        alert("Too many dlist calls");
        this.core.terminate = true;
      }
    }

    //TODO: end rendering
    RDP_GFX_PopDL() {
      this.dlistStackPointer -= 1;
    }

    RSP_RDP_Nothing(pc) {}

    //@videoLog "RSP RDP NOTHING"
    //@dlistStackPointer -= 1
    RSP_GBI1_MoveMem(pc) {
      var addr, dwLight, seg, type;
      type = this.getGbi1Type(pc);
      seg = this.getGbi0DlistAddr(pc);
      addr = this.getRspSegmentAddr(seg);
      switch (type) {
        case consts.RSP_GBI1_MV_MEM_VIEWPORT:
          this.RSP_MoveMemViewport(addr);
          break;
        //case RSP_GBI1_MV_MEM_LOOKATY:
        //break;
        //case RSP_GBI1_MV_MEM_LOOKATX:
        //break;
        case consts.RSP_GBI1_MV_MEM_L0:
        case consts.RSP_GBI1_MV_MEM_L1:
        case consts.RSP_GBI1_MV_MEM_L2:
        case consts.RSP_GBI1_MV_MEM_L3:
        case consts.RSP_GBI1_MV_MEM_L4:
        case consts.RSP_GBI1_MV_MEM_L5:
        case consts.RSP_GBI1_MV_MEM_L6:
        case consts.RSP_GBI1_MV_MEM_L7:
          dwLight = (type - consts.RSP_GBI1_MV_MEM_L0) / 2;
          this.RSP_MoveMemLight(dwLight, addr, pc);
          break;
        case consts.RSP_GBI1_MV_MEM_MATRIX1:
          this.RSP_GFX_Force_Matrix(pc);
      }
    }

    RSP_GFX_Force_Matrix(pc) {
      return this.RSP_GBI0_Mtx(pc);
    }

    RSP_MoveMemViewport(addr) {
      var centerX, centerY, maxZ, scale, trans;
      this.videoLog("RSP_MoveMemViewport");
      if (addr + 16 >= this.core.currentRdramSize) {
        console.warn("viewport addresses beyond mem size");
        return;
      }
      scale = new Float32Array(4);
      trans = new Float32Array(4);
      scale[0] = this.getShort(addr + 0 * 2);
      scale[1] = this.getShort(addr + 1 * 2);
      scale[2] = this.getShort(addr + 2 * 2);
      scale[3] = this.getShort(addr + 3 * 2);
      trans[0] = this.getShort(addr + 4 * 2);
      trans[1] = this.getShort(addr + 5 * 2);
      trans[2] = this.getShort(addr + 6 * 2);
      trans[3] = this.getShort(addr + 7 * 2);
      centerX = trans[0] / 4.0;
      centerY = trans[1] / 4.0;
      this.n64ViewportWidth = scale[0] / 4.0;
      this.n64ViewportHeight = scale[1] / 4.0;
      if (this.n64ViewportWidth < 0) {
        this.n64ViewportWidth = -this.n64ViewportWidth;
      }
      if (this.n64ViewportHeight < 0) {
        this.n64ViewportHeight = -this.n64ViewportHeight;
      }
      this.n64ViewportLeft = centerX - this.n64ViewportWidth;
      this.n64ViewportTop = centerY - this.n64ViewportHeight;
      this.n64ViewportRight = centerX + this.n64ViewportWidth;
      this.n64ViewportBottom = centerY + this.n64ViewportHeight;
      maxZ = 0x3FF;
    }

    //@setViewPort left, top, right, bottom, maxZ
    RSP_GBI1_SpNoop(pc) {}

    //@videoLog "RSP_GBI1_SpNoop"
    RSP_GBI1_Reserved(pc) {}

    //@videoLog "RSP_GBI1_Reserved"
    setProjection(mat, bPush, bReplace) {
      if (bPush === true) {
        if (this.gRSP.projectionMtxTop >= (this.RICE_MATRIX_STACK - 1)) {
          this.gRSP.bMatrixIsUpdated = true;
          this.inverseTransposeCalculated = false;
          return;
        }
        this.gRSP.projectionMtxTop += 1;
        // We should store the current projection matrix...
        if (bReplace) {
          // Load projection matrix
          mat4.set(mat, this.gRSP.projectionMtxs[this.gRSP.projectionMtxTop]);
        } else {
          mat4.multiply(this.gRSP.projectionMtxs[this.gRSP.projectionMtxTop - 1], mat, this.gRSP.projectionMtxs[this.gRSP.projectionMtxTop]);
        }
      } else {
        if (bReplace) {
          // Load projection matrix
          mat4.set(mat, this.gRSP.projectionMtxs[this.gRSP.projectionMtxTop]);
        } else {
          mat4.multiply(this.gRSP.projectionMtxs[this.gRSP.projectionMtxTop], mat, this.gRSP.projectionMtxs[this.gRSP.projectionMtxTop]);
        }
      }
      this.gRSP.bMatrixIsUpdated = true;
      this.inverseTransposeCalculated = false;
      //hack to show Mario's head (as an ortho projection. This if/else is wrong.
      if (this.gRSP.projectionMtxs[this.gRSP.projectionMtxTop][14] > 0) {
        mat4.ortho(-1024, 1024, -1024, 1024, -1023.0, 1024.0, this.gRSP.projectionMtxs[this.gRSP.projectionMtxTop]);
      } else {
        mat4.ortho(-1, 1, -1, 1, -1, 1, 1.0, 1024.0, this.gRSP.projectionMtxs[this.gRSP.projectionMtxTop]);
      }
    }

    setWorldView(mat, bPush, bReplace) {
      if (bPush === true) {
        if (this.gRSP.modelViewMtxTop >= (this.RICE_MATRIX_STACK - 1)) {
          this.gRSP.bMatrixIsUpdated = true;
          this.inverseTransposeCalculated = false;
          return;
        }
        this.gRSP.modelViewMtxTop += 1;
        if (bReplace) {
          // Load modelView matrix
          mat4.set(mat, this.gRSP.modelviewMtxs[this.gRSP.modelViewMtxTop]);
        } else {
          mat4.multiply(this.gRSP.modelviewMtxs[this.gRSP.modelViewMtxTop - 1], mat, this.gRSP.modelviewMtxs[this.gRSP.modelViewMtxTop]);
        }
      } else {
        if (bReplace) {
          // Load modelView matrix
          mat4.set(mat, this.gRSP.modelviewMtxs[this.gRSP.modelViewMtxTop]);
        } else {
          // Multiply modelView matrix
          mat4.multiply(this.gRSP.modelviewMtxs[this.gRSP.modelViewMtxTop], mat, this.gRSP.modelviewMtxs[this.gRSP.modelViewMtxTop]);
        }
      }
      this.gRSP.bMatrixIsUpdated = true;
      this.inverseTransposeCalculated = false;
    }

    RSP_GBI0_Mtx(pc) {
      var addr, seg;
      addr = void 0;
      seg = this.getGbi0DlistAddr(pc);
      addr = this.getRspSegmentAddr(seg);
      //@videoLog "RSP_GBI0_Mtx addr: " + dec2hex(addr)
      this.loadMatrix(addr);
      if (this.gbi0isProjectionMatrix(pc)) {
        this.setProjection(this.matToLoad, this.gbi0PushMatrix(pc), this.gbi0LoadMatrix(pc));
      } else {
        this.setWorldView(this.matToLoad, this.gbi0PushMatrix(pc), this.gbi0LoadMatrix(pc));
      }
      this.renderStateChanged = true;
    }

    loadMatrix(addr) {
      var a, b, i, j, k;
      //  todo: port and probably log warning message if true
      if (addr + 64 > this.core.currentRdramSize) {
        console.warn("loading matrix beyond ram size");
        return;
      }
      i = void 0;
      j = void 0;
      a = addr;
      b = void 0;
      k = 0;
      i = 0;
      const u8 = this.core.memory.u8;
      const matToLoad = this.matToLoad;
      while (i < 4) {
        j = 0;
        while (j < 4) {
          // 0.0000152587890625 is 1.0/65536.0
          matToLoad[k] = ((u8[a] << 24 | u8[a + 1] << 16 | u8[a + 32] << 8 | u8[a + 32 + 1]) >> 0) * 0.0000152587890625;
          k += 1;
          a += 2;
          j += 1;
        }
        i += 1;
      }
    }

    //tile info.
    DLParser_SetTImg(pc) {
      this.texImg.format = this.getTImgFormat(pc);
      this.texImg.size = this.getTImgSize(pc);
      this.texImg.width = this.getTImgWidth(pc) + 1;
      this.texImg.addr = this.getTImgAddr(pc);
      this.texImg.bpl = this.texImg.width << this.texImg.size >> 1;
      this.texImg.changed = true; //no texture cache
    }

    //this.videoLog('Texture: format=' + this.texImg.format + ' size=' + this.texImg.size + ' ' + 'width=' + this.texImg.width + ' addr=' + this.texImg.addr + ' bpl=' + this.texImg.bpl);
    //console.log "SetTImg: Format:"+ @texImg.format + " Size:" + @texImg.size + " Width: "+ @texImg.width
    RSP_GBI0_Vtx(pc) {
      var addr, num, seg, v0;
      num = this.getGbi0NumVertices(pc) + 1;
      v0 = this.getGbi0Vertex0(pc);
      seg = this.getGbi0DlistAddr(pc);
      addr = this.getRspSegmentAddr(seg);
      if ((v0 + num) > this.MAX_VERTICES) {
        num = 32 - v0;
      }
      //Check that the address is valid
      if ((addr + num * 16) > this.core.currentRdramSize) {
        console.warn("vertex is beyond ram size");
      } else {
        this.processVertexData(addr, v0, num);
      }
    }

    RSP_GBI1_Vtx(pc) {
      var addr, num, seg, v0;
      num = this.getGbi1NumVertices(pc);
      v0 = this.getGbi1Vertex0(pc);
      seg = this.getGbi0DlistAddr(pc);
      addr = this.getRspSegmentAddr(seg);
      if ((v0 + num) > this.MAX_VERTICES) {
        return;
      }
      //Check that the address is valid
      if (addr > this.core.currentRdramSize) {
        console.warn("vertex is beyond ram size");
      } else {
        this.processVertexData(addr, v0, num);
      }
    }

    RSP_GBI1_Sprite2DBase(pc) {
      this.videoLog("todo: RSP_GBI1_Sprite2DBase");
    }

    RSP_GBI1_LoadUCode(pc) {
      this.videoLog("todo: RSP_GBI1_LoadUCode");
    }

    RSP_GBI1_BranchZ(pc) {
      this.videoLog("todo: RSP_GBI1_BranchZ");
    }

    RSP_GBI1_Tri2(pc) {
      var cmd, didSucceed, func, mult, v0, v1, v2, v3, v4, v5;
      mult = this.vertexMult;
      v0 = this.getGbi0Tri1V0(pc) * mult;
      v1 = this.getGbi0Tri1V1(pc) * mult;
      v2 = this.getGbi0Tri1V2(pc) * mult;
      //flag = @getGbi0Tri1Flag(pc)
      didSucceed = this.prepareTriangle(v0, v1, v2);
      if (didSucceed === false) {
        return;
      }
      v3 = this.getGbi1Tri2V3(pc) * mult;
      v4 = this.getGbi1Tri2V4(pc) * mult;
      v5 = this.getGbi1Tri2V5(pc) * mult;
      //flag = @getGbi0Tri1Flag(pc)
      didSucceed = this.prepareTriangle(v3, v4, v5);
      if (didSucceed === false) {
        return;
      }
      pc = this.dlistStack[this.dlistStackPointer].pc;
      cmd = this.getCommand(pc);
      func = this.currentMicrocodeMap[cmd];
      if (func === this.RSP_GBI1_Tri2) { //loops until not tri2, then it will drawScene
        return;
      }
      if (this.renderStateChanged === true) {
        this.drawScene(false, this.activeTile);
      }
    }

    RSP_GBI1_ModifyVtx(pc) {
      var type, value, vtx;
      type = this.getGbi1Type(pc);
      vtx = (this.getWord0(pc) & 0xFFFF) >>> 1;
      value = this.getWord1(pc);
      if (vtx > 80) {
        return;
      }
      switch (type) {
        case consts.RSP_MV_WORD_OFFSET_POINT_RGBA:
        case consts.RSP_MV_WORD_OFFSET_POINT_XYSCREEN:
        case consts.RSP_MV_WORD_OFFSET_POINT_ZSCREEN:
        case consts.RSP_MV_WORD_OFFSET_POINT_ST:
          this.modifyVertexInfo(type, vtx, value);
      }
    }

    RSP_S2DEX_SPObjLoadTxtr_Ucode1(pc) {
      this.videoLog("todo: RSP_S2DEX_SPObjLoadTxtr_Ucode1");
    }

    processLights(vo, i, a, sMult, tMult) {
      const n = this.normalMat;
      var o, tempVec3, v, vect;
      o = 0;
      vo |= 0;
      i |= 0;
      while (i < 0) {
        v = this.N64VertexList[vo + i];
        n[0] = this.getVertexNormalX(a);
        i += 1;
        n[1] = this.getVertexNormalY(a);
        n[2] = this.getVertexNormalZ(a);
        //n[3] = 1.0
        tempVec3 = new Float32Array(this.tempVec3Buffer, o);
        v.u = this.getVertexS(a) * sMult;
        v.w = this.getVertexW(a);
        mat4.multiplyVec3(this.modelViewTransposedInverse, n, tempVec3);
        v.y = this.getVertexY(a);
        v.z = this.getVertexZ(a);
        vect = vec3.normalize(tempVec3);
        v.v = this.getVertexT(a) * tMult;
        v.x = this.getVertexX(a);
        this.lightVertex(vect, v);
        a += 16;
        o += 12;
      }
    }

    processShades(vo, i, a, sMult, tMult) {
      var v;
      while (i < 0) {
        v = this.N64VertexList[vo + i];
        v.w = this.getVertexW(a);
        v.x = this.getVertexX(a);
        v.y = this.getVertexY(a);
        i += 1;
        v.u = this.getVertexS(a) * sMult;
        v.z = this.getVertexZ(a);
        v.r = this.getVertexColorR(a);
        v.g = this.getVertexColorG(a);
        v.b = this.getVertexColorB(a);
        v.a = this.getVertexAlpha(a);
        v.v = this.getVertexT(a) * tMult;
        a += 16;
      }
    }

    processPrims(vo, i, a, sMult, tMult) {
      var v;
      while (i < 0) {
        v = this.N64VertexList[vo + i];
        v.w = this.getVertexW(a);
        v.r = this.primColor[0];
        v.x = this.getVertexX(a);
        i += 1;
        v.u = this.getVertexS(a) * sMult;
        v.g = this.primColor[1];
        v.y = this.getVertexY(a);
        v.b = this.primColor[2];
        v.z = this.getVertexZ(a);
        v.a = this.primColor[3];
        v.v = this.getVertexT(a) * tMult;
        a += 16;
      }
    }

    processVertexData(addr, v0, num) {
      var a, i;
      a = addr | 0;
      i = -num;
      const vo = v0+num;
      const tile = this.textureTile[this.activeTile];
      const texWidth = (((tile.lrs >> 2) + 1) - tile.uls)|0;
      const texHeight = (((tile.lrt >> 2) + 1) - tile.ult)|0;
      const sMult = 1.0 / (texWidth<<5);
      const tMult = 1.0 / (texHeight<<5);
      if (this.bLightingEnable === true) {
        if (this.inverseTransposeCalculated === false && this.gRSP.bMatrixIsUpdated === true) {
          mat4.inverse(this.gRSP.modelviewMtxs[this.gRSP.modelViewMtxTop], this.modelViewInverse);
          mat4.transpose(this.modelViewInverse, this.modelViewTransposedInverse);
          this.inverseTransposeCalculated = true;
        }
        this.processLights(vo, i, a, sMult, tMult);
      } else if (this.bShade === true) {
        this.processShades(vo, i, a, sMult, tMult);
      } else {
        this.processPrims(vo, i, a, sMult, tMult);
      }
    }

    modifyVertexInfo(type, vtx, value) {
      switch (type) {
        case consts.RSP_MV_WORD_OFFSET_POINT_RGBA: // Modify RGBA
          alert("RSP_MV_WORD_OFFSET_POINT_RGBA");
          break;
        // uint32 r = (value>>24)&0xFF
        // uint32 g = (value>>16)&0xFF
        // uint32 b = (value>>8)&0xFF
        // uint32 a = val&0xFF
        // g_dwVtxDifColor[vertex] = COLOR_RGBA(r, g, b, a);
        case consts.RSP_MV_WORD_OFFSET_POINT_XYSCREEN: // Modify X,Y
          alert("RSP_MV_WORD_OFFSET_POINT_XYSCREEN");
          break;
        // uint16 nX = (uint16)(val>>16);
        // short x = *((short*)&nX);
        // x /= 4;

          // uint16 nY = uint16(val&0xFFFF);
        // short y = *((short*)&nY);
        // y /= 4;

          // # Should do viewport transform.

          // x -= windowSetting.uViWidth/2;
        // y = windowSetting.uViHeight/2-y;

          // # if( options.bEnableHacks && ((*g_GraphicsInfo.VI_X_SCALE_REG)&0xF) != 0 )
        // # {
        // #   # Tarzan
        // #   # I don't know why Tarzan is different
        // #   SetVertexXYZ(vertex, x/windowSetting.fViWidth, y/windowSetting.fViHeight, g_vecProjected[vertex].z);
        // # }
        // # else
        // # {
        //   # Toy Story 2 and other games
        // SetVertexXYZ(vertex, x*2/windowSetting.fViWidth, y*2/windowSetting.fViHeight, g_vecProjected[vertex].z);
        // # }
        case consts.RSP_MV_WORD_OFFSET_POINT_ZSCREEN: // Modify C
          alert("RSP_MV_WORD_OFFSET_POINT_XYSCREEN");
          break;
        // int z = val>>16;

          // SetVertexXYZ(vertex, g_vecProjected[vertex].x, g_vecProjected[vertex].y, (((float)z/0x03FF)+0.5f)/2.0f );
        case consts.RSP_MV_WORD_OFFSET_POINT_ST: // Texture
          alert("RSP_MV_WORD_OFFSET_POINT_ST");
      }
    }

    // short tu = short(val>>16);
    // short tv = short(val & 0xFFFF);
    // float ftu = tu / 32.0f;
    // float ftv = tv / 32.0f;
    // CRender::g_pRender->SetVtxTextureCoord(vertex, ftu/gRSP.fTexScaleX, ftv/gRSP.fTexScaleY);
    DLParser_SetCImg(pc) {
      var seg;
      this.zColorImage.fmt = this.getSetTileFmt(pc);
      this.zColorImage.siz = this.getSetTileSiz(pc);
      this.zColorImage.width = this.getTImgWidth(pc) + 1;
      seg = this.getGbi0DlistAddr(pc);
      this.zColorImage.addr = this.getRspSegmentAddr(seg);
    }

    DLParser_SetZImg(pc) {
      var seg;
      this.zDepthImage.fmt = this.getSetTileFmt(pc);
      this.zDepthImage.siz = this.getSetTileSiz(pc);
      this.zDepthImage.width = this.getTImgWidth(pc) + 1;
      seg = this.getGbi0DlistAddr(pc);
      this.zDepthImage.addr = this.getRspSegmentAddr(seg);
    }

    //Gets new display list address
    RSP_GBI0_DL(pc) {
      var addr, param, seg;
      param = void 0;
      seg = this.getGbi0DlistAddr(pc);
      addr = this.getRspSegmentAddr(seg);
      //@videoLog "dlist address = " + dec2hex(addr)

      //TODO: address adjust
      param = this.getGbi0DlistParam(pc);
      if (param === consts.RSP_DLIST_PUSH) {
        this.dlistStackPointer += 1;
      }
      this.dlistStack[this.dlistStackPointer].pc = addr;
      this.dlistStack[this.dlistStackPointer].countdown = consts.MAX_DL_COUNT;
    }

    DLParser_SetCombine(pc) {
      const lo = this.getCombineLo(pc) >>> 0;
      const hi = this.getCombineHi(pc) >>> 0;
      this.combine[0] = (lo >> 20) & 15; // @getCombineA0(pc)
      this.combine[2] = (hi >> 28) & 15; // @getCombineB0(pc)
      this.combine[4] = (lo >> 15) & 31; // @getCombineC0(pc)
      this.combine[6] = (hi >> 15) & 7; // @getCombineD0(pc)
      // @combineA0 = 0xFF if @combineA0 is 15
      // @combineB0 = 0xFF if @combineB0 is 15
      // @combineC0 = 0xFF if @combineC0 is 31
      // @combineD0 = 0xFF if @combineD0 is 7
      this.combine[1] = (lo >> 12) & 7; // @getCombineA0a(pc)
      this.combine[3] = (hi >> 12) & 7; // @getCombineB0a(pc)
      this.combine[5] = (lo >> 9) & 7; // @getCombineC0a(pc)
      this.combine[7] = (hi >> 9) & 7; // @getCombineD0a(pc)
      // @combineA0a = 0xFF if @combineA0a is 7
      // @combineB0a = 0xFF if @combineB0a is 7
      // @combineC0a = 0xFF if @combineC0a is 7
      // @combineD0a = 0xFF if @combineD0a is 7
      this.combine[8] = (lo >> 5) & 15; // @getCombineA1(pc)
      this.combine[10] = (hi >> 24) & 15; // @getCombineB1(pc)
      this.combine[12] = lo & 31; // @getCombineC1(pc)
      this.combine[14] = (hi >> 6) & 7; // @getCombineD1(pc)
      // @combineA1 = 0xFF if @combineA1 is 15
      // @combineB1 = 0xFF if @combineB1 is 15
      // @combineC1 = 0xFF if @combineC1 is 31
      // @combineD1 = 0xFF if @combineD1 is 7
      this.combine[9] = (hi >> 21) & 7; // @getCombineA1a(pc)
      this.combine[11] = (hi >> 3) & 7; // @getCombineB1a(pc)
      this.combine[13] = (hi >> 18) & 7; // @getCombineC1a(pc)
      this.combine[15] = hi & 7; // @getCombineD1a(pc)
      // @combineA1a = 0xFF if @combineA1a is 7
      // @combineB1a = 0xFF if @combineB1a is 7
      // @combineC1a = 0xFF if @combineC1a is 7
      // @combineD1a = 0xFF if @combineD1a is 7

      //   w0 = @core.memory.u8[pc] << 24 | @core.memory.u8[pc + 1] << 16 | @core.memory.u8[pc + 2] << 8 | @core.memory.u8[pc + 3]
      //   w1 = @core.memory.u8[pc + 4] << 24 | @core.memory.u8[pc + 5] << 16 | @core.memory.u8[pc + 6] << 8 | @core.memory.u8[pc + 7]

      //if (@combineD0 == 4)
      //  console.log " a0:" + @combineA0 + " b0:" + @combineB0 + " c0:" + @combineC0 + " d0:" + @combineD0 + " a0a:" + @combineA0a + " b0a:" + @combineB0a + " c0a:" + @combineC0a + " d0a:" + @combineD0a + " a1:" + @combineA1 + " b1:" + @combineB1 + " c1:" + @combineC1 + " d1:" + @combineD1 + " a1a:" + @combineA1a + " b1a:" + @combineB1a + " c1a:" + @combineC1a + " d1a:" + @combineD1a

      //@videoLog "TODO: DLParser_SetCombine"
      this.core.webGL.setCombineUniforms(this, this.core.webGL.shaderProgram);
    }

    RSP_GBI1_MoveWord(pc) {
      var dwBase, dwNumLights, dwSegment, field, light;
      //@videoLog "RSP_GBI1_MoveWord"
      switch (this.getGbi0MoveWordType(pc)) {
        case consts.RSP_MOVE_WORD_MATRIX:
          this.RSP_RDP_InsertMatrix();
          break;
        case consts.RSP_MOVE_WORD_SEGMENT:
          dwBase = void 0;
          dwSegment = (this.getGbi0MoveWordOffset(pc) >> 2) & 0x0F;
          dwBase = this.getGbi0MoveWordValue(pc) & 0xFFFFFF;
          this.segments[dwSegment] = dwBase;
          break;
        case consts.RSP_MOVE_WORD_NUMLIGHT:
          dwNumLights = (this.getGbi0MoveWordValue(pc) << 1 >>> 6) - 1;
          this.gRSP.ambientLightIndex = dwNumLights;
          this.gRSPnumLights = dwNumLights;
          break;
        case consts.RSP_MOVE_WORD_LIGHTCOL:
          light = this.getGbi0MoveWordOffset(pc) >>> 5;
          field = this.getGbi0MoveWordOffset(pc) >>> 0 & 0x7;
          if (field === 0) {
            if (light === this.gRSP.ambientLightIndex) {
              this.setAmbientLight(this.getGbi0MoveWordValue(pc));
            } else {
              this.setLightCol(light, this.getGbi0MoveWordValue(pc));
            }
          }
          break;
        case consts.RSP_MOVE_WORD_POINTS:
          alert("RSP_MOVE_WORD_POINTS");
      }
    }

    setAmbientLight(col) {
      var a, b, g, r;
      this.gRSP.ambientLightColor = col;
      r = (col >>> 24) & 0xff;
      g = (col >>> 16) & 0xff;
      b = (col >>> 8) & 0xff;
      a = col & 0xff;
      this.gRSP.fAmbientLightR = r;
      this.gRSP.fAmbientLightG = g;
      this.gRSP.fAmbientLightB = b;
      this.gRSP.fAmbientLightA = a;
    }

    setLightCol(dwLight, dwCol) {
      var a, b, g, r;
      r = (dwCol >>> 24) & 0xFF;
      g = (dwCol >>> 16) & 0xFF;
      b = (dwCol >>> 8) & 0xFF;
      a = (dwCol >>> 0) & 0xFF;
      this.gRSPlights[dwLight].r = r;
      this.gRSPlights[dwLight].g = g;
      this.gRSPlights[dwLight].b = b;
      this.gRSPlights[dwLight].a = a;
    }

    setLightDirection(dwLight, x, y, z) {
      var lightVec;
      lightVec = new Float32Array(3);
      lightVec[0] = x;
      lightVec[1] = y;
      lightVec[2] = z;
      lightVec = vec3.normalize(lightVec);
      this.gRSPlights[dwLight].x = lightVec[0];
      this.gRSPlights[dwLight].y = lightVec[1];
      this.gRSPlights[dwLight].z = lightVec[2];
    }

    lightVertex(norm, v) {
      var b, fCosT, g, l, light, m, r, ref;
      r = this.gRSP.fAmbientLightR;
      g = this.gRSP.fAmbientLightG;
      b = this.gRSP.fAmbientLightB;
//a = @gRSP.fAmbientLightA
      for (l = m = 0, ref = this.gRSPnumLights; (0 <= ref ? m < ref : m > ref); l = 0 <= ref ? ++m : --m) {
        light = this.gRSPlights[l];
        fCosT = norm[0] * light.x + norm[1] * light.y + norm[2] * light.z;
        if (fCosT > 0) {
          r += light.r * fCosT;
          g += light.g * fCosT;
          b += light.b * fCosT;
        }
      }
      //a += light.a * fCosT
      if (r < 0.0) {
        r = 0.0;
      }
      if (g < 0.0) {
        g = 0.0;
      }
      if (b < 0.0) {
        b = 0.0;
      }
      //if a < 0.0
      //  a = 0.0
      if (r > 255.0) {
        r = 255.0;
      }
      if (g > 255.0) {
        g = 255.0;
      }
      if (b > 255.0) {
        b = 255.0;
      }
      //if a > 255.0
      //  a = 255.0
      v.r = r;
      v.g = g;
      v.b = b;
      v.a = 255.0;
    }

    RSP_MoveMemLight(dwLight, dwAddr, pc) {
      var dwCol;
      if (dwLight >= 16) {
        return;
      }
      this.gRSPn64lights[dwLight].dwRGBA = this.getGbi0MoveWordValue(dwAddr);
      this.gRSPn64lights[dwLight].dwRGBACopy = this.getGbi0MoveWordValue(dwAddr + 4);
      this.gRSPn64lights[dwLight].x = this.getVertexLightX(dwAddr);
      this.gRSPn64lights[dwLight].y = this.getVertexLightY(dwAddr);
      this.gRSPn64lights[dwLight].z = this.getVertexLightZ(dwAddr);
      // disabled in Rice's code.
      // /*
      // {
      //   // Normalize light
      //   double sum = (double)gRSPn64lights[dwLight].x * gRSPn64lights[dwLight].x;
      //   sum += (double)gRSPn64lights[dwLight].y * gRSPn64lights[dwLight].y;
      //   sum += (double)gRSPn64lights[dwLight].z * gRSPn64lights[dwLight].z;
      //   sum = sqrt(sum);
      //   sum = sum/128.0;
      //   gRSPn64lights[dwLight].x /= sum;
      //   gRSPn64lights[dwLight].y /= sum;
      //   gRSPn64lights[dwLight].z /= sum;
      // }
      // */

      // normalize light
      // sum = @gRSPn64lights[dwLight].x * @gRSPn64lights[dwLight].x
      // sum += @gRSPn64lights[dwLight].y * @gRSPn64lights[dwLight].y
      // sum += @gRSPn64lights[dwLight].z * @gRSPn64lights[dwLight].z
      // sum = Math.sqrt(sum)
      // sum = sum/128.0
      // @gRSPn64lights[dwLight].x /= sum
      // @gRSPn64lights[dwLight].y /= sum
      // @gRSPn64lights[dwLight].z /= sum
      if (dwLight === this.gRSP.ambientLightIndex) {
        dwCol = this.gRSPn64lights[dwLight].dwRGBA;
        this.setAmbientLight(dwCol);
      } else {
        this.setLightCol(dwLight, this.gRSPn64lights[dwLight].dwRGBA);
        if (this.getGbi0MoveWordValue(dwAddr + 4) === 0) { // Direction is 0! // This sucks. Give it a better name

        } else {
          this.setLightDirection(dwLight, this.gRSPn64lights[dwLight].x, this.gRSPn64lights[dwLight].y, this.gRSPn64lights[dwLight].z);
        }
      }
    }

    renderReset() {
      //UpdateClipRectangle();
      //@resetMatrices()
      this.gRSP.projectionMtxTop = 0;
      this.gRSP.modelViewMtxTop = 0;
      //SetZBias(0);
      this.gRSP.numVertices = 0;
      this.gRSP.curTile = 0;
      //    @gRSP.fTexScaleX = 1 / 32.0
      //    @gRSP.fTexScaleY = 1 / 32.0
      this.gl.clearDepth(1.0);
      this.gl.depthMask(true);
      this.gl.clear(this.gl.DEPTH_BUFFER_BIT);
    }

    resetMatrices() {
      var i;
      this.gRSP.projectionMtxTop = 0;
      this.gRSP.modelViewMtxTop = 0;
      mat4.identity(this.gRSP.modelviewMtxs[0]);
      mat4.identity(this.gRSP.projectionMtxs[0]);
      i = 0;
      while (i < this.RICE_MATRIX_STACK) {
        mat4.identity(this.gRSP.projectionMtxs[i]);
        mat4.identity(this.gRSP.modelviewMtxs[i]);
        i += 1;
      }
      this.gRSP.bMatrixIsUpdated = false;
      this.inverseTransposeCalculated = false;
    }

    RSP_RDP_InsertMatrix() {
      this.videoLog("TODO: Insert Matrix");
      this.gRSP.bMatrixIsUpdated = false;
    }

    DLParser_SetScissor(pc) {
      this.videoLog("TODO: DLParser_SetScissor");
    }

    RSP_GBI1_SetOtherModeH(pc) {
      var length, mask, shift, word0;
      word0 = this.getOtherModeH(pc);
      length = (word0 >>> 0) & 0xFF;
      shift = (word0 >>> 8) & 0xFF;
      mask = ((1 << length) - 1) << shift;
      this.otherModeH &= ~mask;
      this.otherModeH |= this.getOtherModeH(pc + 4);
      //alert @otherModeH
      this.renderStateChanged = true;
    }

    RSP_GBI1_SetOtherModeL(pc) {
      var length, mask, shift, word0;
      word0 = this.getOtherModeL(pc);
      length = (word0 >>> 0) & 0xFF;
      shift = (word0 >>> 8) & 0xFF;
      mask = ((1 << length) - 1) << shift;
      this.otherModeL &= ~mask;
      this.otherModeL |= this.getOtherModeL(pc + 4);
      //alert dec2hex @otherModeL
      this.DLParser_RDPSetOtherModeL(this.otherModeL);
      this.renderStateChanged = true;
    }

    RSP_GBI0_Sprite2DBase(pc) {
      this.videoLog("TODO: RSP_GBI0_Sprite2DBase");
    }

    RSP_GBI0_Tri4(pc) {
      this.videoLog("TODO: RSP_GBI0_Tri4");
    }

    RSP_GBI1_RDPHalf_Cont(pc) {}

    //@videoLog "TODO: RSP_GBI1_RDPHalf_Cont"
    RSP_GBI1_RDPHalf_2(pc) {}

    //@videoLog "TODO: RSP_GBI1_RDPHalf_2"
    RSP_GBI1_RDPHalf_1(pc) {
      this.videoLog("TODO: RSP_GBI1_RDPHalf_1");
    }

    RSP_GBI1_Line3D(pc) {
      var cmd, didSucceed, func, mult, v0, v1, v2, v3;
      mult = this.vertexMult;
      v0 = this.getGbi1Line3dV0(pc) * mult;
      v1 = this.getGbi1Line3dV1(pc) * mult;
      v2 = this.getGbi1Line3dV2(pc) * mult;
      v3 = this.getGbi1Line3dV3(pc) * mult;
      //flag = @getGbi0Tri1Flag(pc)
      didSucceed = this.prepareTriangle(v0, v1, v2);
      if (didSucceed === false) {
        return;
      }
      //flag = @getGbi0Tri1Flag(pc)
      didSucceed = this.prepareTriangle(v2, v3, v0);
      if (didSucceed === false) {
        return;
      }
      pc = this.dlistStack[this.dlistStackPointer].pc;
      cmd = this.getCommand(pc);
      func = this.currentMicrocodeMap[cmd];
      if (func === this.RSP_GBI1_Line3D) { //loops until not tri2, then it will drawScene
        return;
      }
      if (this.renderStateChanged === true) {
        this.drawScene(false, this.activeTile);
      }
    }

    RSP_GBI1_ClearGeometryMode(pc) {
      var data;
      data = this.getClearGeometryMode(pc) >>> 0;
      this.geometryMode &= ~data;
      this.initGeometryMode();
      this.setDepthTest();
    }

    RSP_GBI1_SetGeometryMode(pc) {
      var data;
      data = this.getSetGeometryMode(pc) >>> 0;
      this.geometryMode |= data;
      this.initGeometryMode();
      this.setDepthTest();
    }

    initGeometryMode() {
      var bCullBack, bCullFront;
      // cull face
      bCullFront = this.geometryMode & consts.G_CULL_FRONT;
      bCullBack = this.geometryMode & consts.G_CULL_BACK;
      if (bCullBack !== 0 && bCullFront !== 0) {
        this.gl.enable(this.gl.CULL_FACE);
        this.gl.cullFace(this.gl.FRONT_AND_BACK);
      } else if (bCullBack !== 0) {
        this.gl.enable(this.gl.CULL_FACE);
        this.gl.cullFace(this.gl.BACK);
      } else if (bCullFront !== 0) {
        this.gl.enable(this.gl.CULL_FACE);
        this.gl.cullFace(this.gl.FRONT);
      } else {
        this.gl.disable(this.gl.CULL_FACE);
      }
      if ((this.geometryMode & consts.G_SHADE) !== 0) {
        this.bShade = true;
      } else {
        this.bShade = false;
      }
      //this doesn't exist in WebGL, so find a replacement if
      //we need flat-shading.
      //bShadeSmooth = @geometryMode & consts.G_SHADING_SMOOTH
      //if bShade isnt 0 and bShadeSmooth isnt 0
      //  @gl.shadeModel @gl.SMOOTH
      //else
      //  @gl.shadeModel @gl.FLAT
      if ((this.geometryMode & consts.G_TEXTURE_GEN) !== 0) {
        this.bTextureGen = true;
      } else {
        this.bTexueGen = false;
      }
      if ((this.geometryMode & consts.G_LIGHTING) !== 0) {
        this.bLightingEnable = true;
      } else {
        this.bLightingEnable = false;
      }
      if ((this.geometryMode & consts.G_FOG) !== 0) {
        this.bFogEnable = true;
      } else {
        this.bFogEnable = false;
      }
      if ((this.geometryMode & consts.G_ZBUFFER) !== 0) {
        this.bZBufferEnable = true;
      } else {
        this.bZBufferEnable = false;
      }
    }

    RSP_GBI1_EndDL(pc) {
      this.RDP_GFX_PopDL();
      this.drawScene(false, this.activeTile);
    }

    //@resetState()
    RSP_GBI1_Texture(pc) {
      var tile;
      tile = this.getTextureTile(pc);
      this.activeTile = tile;
      this.textureTile[tile].on = this.getTextureOn(pc);
      this.textureTile[tile].level = this.getTextureLevel(pc);
      this.textureTile[tile].scales = this.getTextureScaleS(pc) / 0x8000;
      this.textureTile[tile].scalet = this.getTextureScaleT(pc) / 0x8000;
      //console.log "RSP_GBI1_Texture: Tile:" + tile + " On:" + @textureTile[tile].on + " Level:" + @textureTile[tile].level + " ScaleS:" + @textureTile[tile].scales + " ScaleT:" + @textureTile[tile].scalet
      this.drawScene(false, tile);
    }

    popProjection() {
      if (this.gRSP.projectionMtxTop > 0) {
        this.gRSP.projectionMtxTop--;
      }
    }

    popWorldView() {
      if (this.gRSP.modelViewMtxTop > 0) {
        this.gRSP.modelViewMtxTop--;
        this.gRSPmodelViewTop = this.gRSP.modelviewMtxs[this.gRSP.modelViewMtxTop];
        this.gRSP.bMatrixIsUpdated = true;
        this.inverseTransposeCalculated = false;
      }
    }

    RSP_GBI1_PopMtx(pc) {
      if (this.gbi0PopMtxIsProjection(pc)) {
        this.popProjection();
      } else {
        this.popWorldView();
      }
      this.renderStateChanged = true;
    }

    RSP_GBI1_CullDL(pc) {
      this.videoLog("TODO: RSP_GBI1_CullDL");
    }

    RSP_GBI1_Tri1(pc) {
      var cmd, didSucceed, flag, func, mult, v0, v1, v2;
      mult = this.vertexMult;
      v0 = this.getGbi0Tri1V0(pc) * mult;
      v1 = this.getGbi0Tri1V1(pc) * mult;
      v2 = this.getGbi0Tri1V2(pc) * mult;
      flag = this.getGbi0Tri1Flag(pc);
      //console.log "Tri1: "+v0+", "+v1+", "+v2+"   Flag: "+flag
      didSucceed = this.prepareTriangle(v0, v1, v2);
      if (didSucceed === false) {
        return;
      }
      pc = this.dlistStack[this.dlistStackPointer].pc;
      cmd = this.getCommand(pc);
      func = this.currentMicrocodeMap[cmd];
      if (func === this.RSP_GBI1_Tri1) { //loops until not tri1, then it will drawScene
        return;
      }
      if (this.renderStateChanged === true) {
        this.drawScene(false, this.activeTile);
      }
    }

    RSP_GBI1_Noop(pc) {}

    //@videoLog "TODO: RSP_GBI1_Noop"
    RDP_TriFill(pc) {
      this.videoLog("TODO: RDP_TriFill");
    }

    RDP_TriFillZ(pc) {
      this.videoLog("RDP_TriFillZ");
    }

    RDP_TriTxtr(pc) {
      this.videoLog("TODO: RDP_TriTxtr");
    }

    RDP_TriTxtrZ(pc) {
      this.videoLog("TODO: RDP_TriTxtrZ");
    }

    RDP_TriShade(pc) {
      this.videoLog("TODO: RDP_TriShade");
    }

    RDP_TriShadeZ(pc) {
      this.videoLog("TODO: RDP_TriShadeZ");
    }

    RDP_TriShadeTxtr(pc) {
      this.videoLog("TODO: RDP_TriShadeTxtr");
    }

    RDP_TriShadeTxtrZ(pc) {
      this.videoLog("TODO: RDP_TriShadeTxtrZ");
    }

    DLParser_TexRect(pc, isFillRect) {
      var depthTestEnabled, dsdx, dtdy, s, t, tileno, xh, xl, yh, yl;
      depthTestEnabled = true;
      if (depthTestEnabled) {
        //@setDepthTest()
        this.gl.enable(this.gl.DEPTH_TEST);
        this.gl.depthFunc(this.gl.LEQUAL);
      } else {
        this.gl.disable(this.gl.DEPTH_TEST);
      }
      xh = this.getTexRectXh(pc) >>> 2;
      yh = this.getTexRectYh(pc) >>> 2;
      tileno = this.getTexRectTileNo(pc);
      xl = this.getTexRectXl(pc) >>> 2;
      yl = this.getTexRectYl(pc) >>> 2;
      s = this.getTexRectS(pc) >>> 5;
      t = this.getTexRectT(pc) >>> 5;
      dsdx = this.getTexRectDsDx(pc) >>> 10;
      dtdy = this.getTexRectDtDy(pc) >>> 10;
      if (this.cycleType === consts.CYCLE_TYPE_COPY) {
        dsdx *= 0.25;
      }
      if (this.cycleType === consts.CYCLE_TYPE_FILL || this.cycleType === consts.CYCLE_TYPE_COPY) {
        xh += 1.0;
        yh += 1.0;
      }
      //console.log "Texrect: UL("+xl+","+yl+") LR("+xh+","+yh+") Tile:"+tileno+" TexCoord:("+s+","+t+") TexSlope:("+dsdx+","+dtdy+")"
      this.renderer.texRect(tileno, xl, yl, xh, yh, s, t, dsdx, dtdy, this.textureTile[tileno], this.tmem, this, isFillRect);
      this.hasTexture = true;
    }

    //@setDepthTest()
    //@drawScene false, 7
    DLParser_TexRectFlip(pc) {
      this.videoLog("TODO: DLParser_TexRectFlip");
    }

    DLParser_RDPLoadSynch(pc) {
      this.renderStateChanged = true;
    }

    //@videoLog "TODO: DLParser_RDPLoadSynch"
    DLParser_RDPPipeSynch(pc) {}

    //@videoLog "TODO: DLParser_RDPPipeSynch"
    DLParser_RDPTileSynch(pc) {}

    //@videoLog "TODO: DLParser_RDPTileSynch"
    DLParser_RDPFullSynch(pc) {}

    //@drawScene(7, false)
    DLParser_SetKeyGB(pc) {
      this.videoLog("TODO: DLParser_SetKeyGB");
    }

    DLParser_SetKeyR(pc) {
      this.videoLog("TODO: DLParser_SetKeyR");
    }

    DLParser_SetConvert(pc) {
      this.videoLog("TODO: DLParser_SetConvert");
    }

    DLParser_SetPrimDepth(pc) {
      this.videoLog("TODO: DLParser_SetPrimDepth");
    }

    DLParser_RDPSetOtherModeL(otherModeL) {
      if ((otherModeL & (consts.RDP_ALPHA_COMPARE_THRESHOLD | consts.RDP_ALPHA_COMPARE_DITHER)) !== 0) {
        this.alphaTestEnabled = 1;
      } else {
        this.alphaTestEnabled = 0;
      }
    }

    DLParser_LoadTLut(pc) {
      var bytes, i, lrs, lrt, m, ramOffset, ref, tile, tmemOffset, uls, ult;
      tile = this.getSetTileSizeTile(pc);
      uls = this.textureTile[tile].uls = this.getSetTileSizeUls(pc);
      ult = this.textureTile[tile].ult = this.getSetTileSizeUlt(pc);
      lrs = this.textureTile[tile].lrs = this.getSetTileSizeLrs(pc);
      lrt = this.textureTile[tile].lrt = this.getSetTileSizeLrt(pc);
      ramOffset = this.texImg.addr + (ult >>> 2) * ((this.texImg.width << consts.TXT_SIZE_16b) >>> 1) + (((uls >>> 2) << consts.TXT_SIZE_16b) >>> 1);
      bytes = (((lrs - uls) >>> 2) + 1) << 1;
      tmemOffset = this.textureTile[tile].tmem << 3;
      const tlut = this.tlut;
      const ram = this.core.memory.u8;
      for (i = m = 0, ref = bytes; (0 <= ref ? m < ref : m > ref); i = 0 <= ref ? ++m : --m) {
        tlut[tmemOffset + i] = ram[ramOffset + i];
      }
    }

    DLParser_SetTileSize(pc) {
      var tile;
      tile = this.getSetTileSizeTile(pc);
      this.textureTile[tile].uls = this.getSetTileSizeUls(pc);
      this.textureTile[tile].ult = this.getSetTileSizeUlt(pc);
      this.textureTile[tile].lrs = this.getSetTileSizeLrs(pc);
      this.textureTile[tile].lrt = this.getSetTileSizeLrt(pc);
    }

    //console.log "SetTileSize: UL("+@textureTile[tile].uls+"/"+@textureTile[tile].ult+") LR("+@textureTile[tile].lrs+"/"+@textureTile[tile].lrt+") Dim: "+@textureTile[tile].width+"x"+@textureTile[tile].height
    DLParser_LoadBlock(pc) {
      var bytesToXfer, dxt, i, lrs, tile, uls, ult;
      tile = this.getLoadBlockTile(pc);
      uls = this.getLoadBlockUls(pc);
      ult = this.getLoadBlockUlt(pc);
      lrs = this.getLoadBlockLrs(pc);
      dxt = this.getLoadBlockDxt(pc);
      //console.log "LoadBlock: Tile:"+tile+" UL("+uls+"/"+ult+") LRS:"+lrs+" DXT: 0x"+dec2hex(dxt)
      //textureAddr = @core.memory.u8[@texImg.addr])
      bytesToXfer = (lrs + 1) * this.textureTile[tile].siz;
      if (bytesToXfer > 4096) {
        console.error("LoadBlock is making too large of a transfer. " + bytesToXfer + " bytes");
      }
      i = 0;
      const u8 = this.core.memory.u8
    var addr = this.texImg.addr|0
    const tmem = this.tmem;
      while (i < bytesToXfer) {
        tmem[i] = u8[addr];
        i++;
        addr++;
      }
    }

    DLParser_LoadTile(pc) {
      var bytesToXfer, i, lrs, tile;
      tile = this.getLoadBlockTile(pc);
      lrs = this.textureTile[tile].lrs;
      //console.log "LoadBlock: Tile:"+tile+" UL("+uls+"/"+ult+") LRS:"+lrs+" DXT: 0x"+dec2hex(dxt)
      //textureAddr = @core.memory.u8[@texImg.addr])
      bytesToXfer = (lrs + 1) * this.textureTile[tile].siz;
      bytesToXfer = 4096;
      if (bytesToXfer > 4096) {
        console.error("LoadTile is making too large of a transfer. " + bytesToXfer + " bytes");
      }
      i = 0;
      if (typeof this.texImg.addr !== 'undefined') {
        const u8 = this.core.memory.u8
      var addr = this.texImg.addr|0
      const tmem = this.tmem;
        while (i < bytesToXfer) {
          tmem[i] = u8[addr];
          i++;
          addr++;
        }
      }
    }

    DLParser_SetTile(pc) {
      var tile;
      tile = this.getSetTileTile(pc);
      this.textureTile[tile].fmt = this.getSetTileFmt(pc);
      this.textureTile[tile].siz = this.getSetTileSiz(pc);
      this.textureTile[tile].line = this.getSetTileLine(pc);
      this.textureTile[tile].tmem = this.getSetTileTmem(pc);
      this.textureTile[tile].pal = this.getSetTilePal(pc);
      this.textureTile[tile].cmt = this.getSetTileCmt(pc);
      this.textureTile[tile].cms = this.getSetTileCms(pc);
      this.textureTile[tile].mirrorS = this.getSetTileMirrorS(pc);
      this.textureTile[tile].mirrorT = this.getSetTileMirrorT(pc);
      this.textureTile[tile].maskt = this.getSetTileMaskt(pc);
      this.textureTile[tile].masks = this.getSetTileMasks(pc);
      this.textureTile[tile].shiftt = this.getSetTileShiftt(pc);
      this.textureTile[tile].shifts = this.getSetTileShifts(pc);
      this.textureTile[tile].otherModeL = this.otherModeL;
    }

    //if @combineD0 == 4
    //console.log "SetTile:"+tile+" FMT:"+@textureTile[tile].fmt+" SIZ:"+@textureTile[tile].siz+" LINE: "+@textureTile[tile].line+" TMEM:"+@textureTile[tile].tmem+" PAL:"+@textureTile[tile].pal+" CMS/T:"+@textureTile[tile].cms+"/"+@textureTile[tile].cmt+" MASKS/T:"+@textureTile[tile].masks+"/"+@textureTile[tile].maskt+" SHIFTS/T:"+@textureTile[tile].shifts+"/"+@textureTile[tile].shiftt
    DLParser_FillRect(pc) {
      // if @zDepthImage.addr isnt undefined and (@zDepthImage.addr is @zColorImage.addr)
      //   @gl.clearDepth 1.0
      //   @gl.depthMask true
      //   @gl.clear @gl.DEPTH_BUFFER_BIT
      //@gl.clearColor @fillColor[0], @fillColor[1], @fillColor[2], 1.0
      //@gl.clear @gl.COLOR_BUFFER_BIT
      //@gl.clearColor 0.0, 0.0, 0.0, 0.0
      //return
      this.DLParser_TexRect(pc, true);
    }

    // if @fillColor isnt undefined
    //   if @zDepthImage.addr isnt @zColorImage.addr
    //     @gl.clearColor 1.0, @fillColor[1], @fillColor[2], 1.0
    //     @gl.clear @gl.COLOR_BUFFER_BIT
    DLParser_SetFillColor(pc) {
      this.fillColor = [];
      this.fillColor.push(this.getSetFillColorR(pc) / 255.0);
      this.fillColor.push(this.getSetFillColorG(pc) / 255.0);
      this.fillColor.push(this.getSetFillColorB(pc) / 255.0);
      this.fillColor.push(this.getSetFillColorA(pc) / 255.0);
      this.gl.uniform4fv(this.core.webGL.shaderProgram.uFillColor, this.fillColor);
    }

    DLParser_SetFogColor(pc) {
      this.videoLog("TODO: DLParser_SetFogColor");
    }

    DLParser_SetBlendColor(pc) {
      this.blendColor = [];
      this.blendColor.push(this.getSetFillColorR(pc) / 255.0);
      this.blendColor.push(this.getSetFillColorG(pc) / 255.0);
      this.blendColor.push(this.getSetFillColorB(pc) / 255.0);
      this.blendColor.push(this.getSetFillColorA(pc) / 255.0);
      this.gl.uniform4fv(this.core.webGL.shaderProgram.uBlendColor, this.blendColor);
    }

    DLParser_SetPrimColor(pc) {
      this.primColor = [];
      this.primColor.push(this.getSetPrimColorR(pc) / 255.0);
      this.primColor.push(this.getSetPrimColorG(pc) / 255.0);
      this.primColor.push(this.getSetPrimColorB(pc) / 255.0);
      this.primColor.push(this.getSetPrimColorA(pc) / 255.0);
      //alert @primColor
      this.gl.uniform4fv(this.core.webGL.shaderProgram.uPrimColor, this.primColor);
    }

    DLParser_SetEnvColor(pc) {
      this.envColor = [];
      this.envColor.push(this.getSetEnvColorR(pc) / 255.0);
      this.envColor.push(this.getSetEnvColorG(pc) / 255.0);
      this.envColor.push(this.getSetEnvColorB(pc) / 255.0);
      this.envColor.push(this.getSetEnvColorA(pc) / 255.0);
      this.gl.uniform4fv(this.core.webGL.shaderProgram.uEnvColor, this.envColor);
    }

    prepareTriangle(dwV0, dwV1, dwV2) {
      var didSucceed, textureFlag;
      //SP_Timing(SP_Each_Triangle);
      didSucceed = void 0; //(CRender::g_pRender->IsTextureEnabled() || this.gRSP.ucode == 6 );
      textureFlag = false;
      didSucceed = this.initVertex(dwV0, this.gRSP.numVertices, textureFlag);
      if (didSucceed) {
        didSucceed = this.initVertex(dwV1, this.gRSP.numVertices + 1, textureFlag);
      }
      if (didSucceed) {
        didSucceed = this.initVertex(dwV2, this.gRSP.numVertices + 2, textureFlag);
      }
      if (didSucceed) {
        this.gRSP.numVertices += 3;
      }
      return didSucceed;
    }

    initVertex(dwV, vtxIndex, bTexture) {
      var colorOffset, offset, texOffset, vertex;
      if (dwV >= consts.MAX_VERTS) {
        //console.log "Vertex Index: "+vtxIndex+" dwV:"+dwV
        return false;
      }
      offset = 4 * this.triangleVertexPositionBuffer.numItems++; // postfix addition is intentional for performance
      vertex = this.N64VertexList[dwV];
      this.triVertices[offset] = vertex.x;
      this.triVertices[offset + 1] = vertex.y;
      this.triVertices[offset + 2] = vertex.z;
      this.triVertices[offset + 3] = vertex.w * this.vertexMult;
      if (vertex.w === 0) {
        this.triVertices[offset + 3] = 1.0;
      }
      colorOffset = this.triangleVertexColorBuffer.numItems++ << 2; // postfix addition is intentional for performance
      this.triColorVertices[colorOffset] = vertex.r;
      this.triColorVertices[colorOffset + 1] = vertex.g;
      this.triColorVertices[colorOffset + 2] = vertex.b;
      this.triColorVertices[colorOffset + 3] = vertex.a;
      texOffset = this.triangleVertexTextureCoordBuffer.numItems++ << 1; // postfix addition is intentional for performance
      this.triTextureCoords[texOffset] = vertex.u;
      this.triTextureCoords[texOffset + 1] = vertex.v;
      return true;
    }

    setBlendFunc() {
      const CYCLE_TYPE_1 = 0;
      const CYCLE_TYPE_2 = 1;
      const CYCLE_TYPE_COPY = 2;
      const CYCLE_TYPE_FILL = 3;
      const CVG_DST_CLAMP = 0;
      const CVG_DST_WRAP = 0x100;
      const CVG_DST_FULL = 0x200;
      const CVG_DST_SAVE = 0x300;
      const BLEND_NOOP = 0x0000;
      const BLEND_NOOP5 = 0xcc48;
      const BLEND_NOOP4 = 0xcc08;
      const BLEND_FOG_ASHADE = 0xc800;
      const BLEND_FOG_3 = 0xc000;
      const BLEND_FOG_MEM = 0xc440;
      const BLEND_FOG_APRIM = 0xc400;
      const BLEND_BLENDCOLOR = 0x8c88;
      const BLEND_BI_AFOG = 0x8400;
      const BLEND_BI_AIN = 0x8040;
      const BLEND_MEM = 0x4c40;
      const BLEND_FOG_MEM_3 = 0x44c0;
      const BLEND_NOOP3 = 0x0c48;
      const BLEND_PASS = 0x0c08;
      const BLEND_FOG_MEM_IN_MEM = 0x0440;
      const BLEND_FOG_MEM_FOG_MEM = 0x04c0;
      const BLEND_OPA = 0x0044;
      const BLEND_XLU = 0x0040;
      const BLEND_MEM_ALPHA_IN = 0x4044;
      var HACK_FOR_MARIO_TENNIS, alphaCvgSel, blendMode1, blendMode2, cvgXAlpha, forceBl, zCmp;
      blendMode1 = this.otherModeL >>> 16 & 0xCCCC;
      blendMode2 = this.otherModeL >>> 16 & 0x3333;
      this.cycleType = this.otherModeH >> 20 & 0x3;
      switch (this.cycleType) {
        case CYCLE_TYPE_FILL:
          this.gl.disable(this.gl.BLEND);
          break;
        case CYCLE_TYPE_COPY:
          //this is wrong, but better for now. Hud has no alpha.
          // We should be calculating alpha transparency at the bottom of this function
          this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
          this.gl.enable(this.gl.BLEND);
          break;
        case CYCLE_TYPE_2:
          forceBl = this.otherModeL >> 14 & 0x1;
          zCmp = this.otherModeL >> 4 & 0x1;
          alphaCvgSel = this.otherModeL >> 13 & 0x1;
          cvgXAlpha = this.otherModeL >> 12 & 0x1;
          if (forceBl === 1 && zCmp === 1) {
            this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
            this.gl.enable(this.gl.BLEND);
          } else {
            // else if alphaCvgSel is 1 && cvgXAlpha is 0
            //   @gl.blendFunc @gl.ONE, @gl.ZERO
            //   @gl.enable @gl.BLEND
            switch (blendMode1 + blendMode2) {
              case BLEND_PASS + (BLEND_PASS >> 2):
              case BLEND_FOG_APRIM + (BLEND_PASS >> 2):
                this.gl.blendFunc(this.gl.ONE, this.gl.ZERO);
                this.gl.enable(this.gl.blendFunc);
                if (this.cvgXAlpha === 1) {
                  this.gl.blendFunc(this.gl.ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
                }
                break;
              //       if( gRDP.otherMode.alpha_cvg_sel )
              //       {
              //         Enable();
              //       }
              //       else
              //       {
              //         Enable();
              //       }
              //       break;
              case BLEND_PASS + (BLEND_OPA >> 2):
                if (cvgXAlpha === 1 && alphaCvgSel === 1) {
                  this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
                  this.gl.enable(this.gl.BLEND);
                } else {
                  this.gl.blendFunc(this.gl.ONE, this.gl.ZERO);
                  this.gl.enable(this.gl.BLEND);
                }
                break;
              case BLEND_PASS + (BLEND_XLU >> 2):
              case BLEND_FOG_ASHADE + (BLEND_XLU >> 2):
              case BLEND_FOG_APRIM + (BLEND_XLU >> 2):
              case BLEND_FOG_MEM_FOG_MEM + (BLEND_PASS >> 2):
              case BLEND_XLU + (BLEND_XLU >> 2):
              case BLEND_BI_AFOG + (BLEND_XLU >> 2):
              case BLEND_XLU + (BLEND_FOG_MEM_IN_MEM >> 2):
              case BLEND_PASS + (BLEND_FOG_MEM_IN_MEM >> 2):
                this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
                this.gl.enable(this.gl.BLEND);
                break;
              case BLEND_FOG_MEM_FOG_MEM + (BLEND_OPA >> 2):
                if (this.fogIsImplemented) {
                  this.gl.blendFunc(this.gl.ONE, this.gl.ZERO);
                  this.gl.enable(this.gl.BLEND);
                } else {
                  this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
                  this.gl.enable(this.gl.BLEND);
                }
                break;
              case BLEND_FOG_APRIM + (BLEND_OPA >> 2):
              case BLEND_FOG_ASHADE + (BLEND_OPA >> 2):
              case BLEND_BI_AFOG + (BLEND_OPA >> 2):
              case BLEND_FOG_ASHADE + (BLEND_NOOP >> 2):
              case BLEND_NOOP + (BLEND_OPA >> 2):
              case BLEND_NOOP4 + (BLEND_NOOP >> 2):
              case BLEND_FOG_ASHADE + (BLEND_PASS >> 2):
              case BLEND_FOG_3 + (BLEND_PASS >> 2):
                if (this.fogIsImplemented) {
                  this.gl.blendFunc(this.gl.ONE, this.gl.ZERO);
                  this.gl.enable(this.gl.BLEND);
                } else {
                  this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
                  this.gl.enable(this.gl.BLEND);
                }
                break;
              case BLEND_FOG_ASHADE + 0x0301:
                this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ZERO);
                this.gl.enable(this.gl.BLEND);
                break;
              case 0x0c08 + 0x1111:
                this.gl.blendFunc(this.gl.ZERO, this.gl.DEST_ALPHA);
                this.gl.enable(this.gl.BLEND);
                break;
              default:
                if (blendMode2 === BLEND_PASS >> 2) {
                  this.gl.blendFunc(this.gl.ONE, this.g.ZERO);
                } else {
                  this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
                }
                this.gl.enable(this.gl.BLEND); // 1/2 Cycle or Copy
            }
          }
          break;
        default:
          forceBl = this.otherModeL >> 14 & 0x1;
          zCmp = this.otherModeL >> 4 & 0x1;
          if (forceBl === 1 && zCmp === 1 && blendMode1 !== BLEND_FOG_ASHADE) {
            this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
            this.gl.enable(this.gl.BLEND);
          } else {
            //    if( gRDP.otherMode.force_bl && options.enableHackForGames == HACK_FOR_COMMANDCONQUER )
            //    {
            //      BlendFunc(D3DBLEND_SRCALPHA, D3DBLEND_INVSRCALPHA);
            //      Enable();
            //      break;
            //    }
            switch (blendMode1) {
              //    //switch ( blendmode_2<<2 )
              case BLEND_XLU:
              case BLEND_BI_AIN:
              case BLEND_FOG_MEM:
              case BLEND_FOG_MEM_IN_MEM:
              case BLEND_BLENDCOLOR:
              case 0x00c0:
                this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
                this.gl.enable(this.gl.BLEND);
                break;
              case BLEND_MEM_ALPHA_IN:
                this.gl.blendFunc(this.gl.ZERO, this.gl.DEST_ALPHA);
                this.gl.enable(this.gl.BLEND);
                break;
              case BLEND_PASS:
                alphaCvgSel = this.otherModeL >> 13 & 0x1;
                this.gl.blendFunc(this.gl.ONE, this.gl.ZERO);
                if (alphaCvgSel !== 0) {
                  this.gl.enable(this.gl.BLEND);
                } else {
                  this.gl.disable(this.gl.BLEND);
                }
                break;
              case BLEND_OPA:
                HACK_FOR_MARIO_TENNIS = true;
                if (HACK_FOR_MARIO_TENNIS) {
                  this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
                } else {
                  this.gl.blendFunc(this.gl.ONE, this.gl.ZERO);
                }
                this.gl.enable(this.gl.BLEND);
                break;
              case BLEND_NOOP:
              case BLEND_FOG_ASHADE:
              case BLEND_FOG_MEM_3:
              case BLEND_BI_AFOG:
                this.gl.blendFunc(this.gl.ONE, this.gl.ZERO);
                this.gl.enable(this.gl.BLEND);
                break;
              case BLEND_FOG_APRIM:
                this.gl.blendFunc(this.gl.ONE_MINUS_SRC_ALPHA, this.gl.ZERO);
                this.gl.enable(this.gl.BLEND);
                break;
              case BLEND_NOOP3:
              case BLEND_NOOP5:
                this.gl.blendFunc(this.gl.ZERO, this.gl.ONE);
                this.gl.enable(this.gl.BLEND);
                break;
              case BLEND_MEM:
                // WaveRace
                this.gl.blendFunc(this.gl.ZERO, this.gl.ONE);
                this.gl.blendEquation(this.gl.FUNC_ADD);
                this.gl.enable(this.gl.BLEND);
                break;
              default:
                this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
                this.gl.blendEquation(this.gl.FUNC_ADD);
                this.gl.enable(this.gl.BLEND);
            }
          }
      }
    }

    //render->SetAlphaTestEnable(TRUE);
    setDepthTest() {
      var zBufferMode, zCmp, zUpd;
      zBufferMode = (this.geometryMode & consts.G_ZBUFFER) !== 0;
      zCmp = (this.otherModeL & consts.Z_COMPARE) !== 0;
      zUpd = (this.otherModeL & consts.Z_UPDATE) !== 0;
      if ((zBufferMode && zCmp) || zUpd) {
        this.gl.enable(this.gl.DEPTH_TEST);
      } else {
        //      @gl.depthFunc @gl.LEQUAL
        //      @gl.depthRange 0, 0.0001 # fixes shadows
        //      @gl.depthMask true
        this.gl.disable(this.gl.DEPTH_TEST);
      }
      this.gl.depthMask(zUpd);
    }

    drawScene(useTexture, tileno) {
      var tData, textureData, tile, tileHeight, tileWidth, wrapS, wrapT;
      this.setBlendFunc();
      this.setDepthTest();
      this.renderStateChanged = false;
      if (this.triangleVertexPositionBuffer.numItems > 0) {
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.triangleVertexPositionBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, this.triVertices.subarray(0, this.triangleVertexPositionBuffer.numItems * this.triangleVertexPositionBuffer.itemSize), this.gl.STATIC_DRAW);
        this.gl.enableVertexAttribArray(this.core.webGL.shaderProgram.vertexPositionAttribute);
        this.gl.vertexAttribPointer(this.core.webGL.shaderProgram.vertexPositionAttribute, this.triangleVertexPositionBuffer.itemSize, this.gl.FLOAT, false, 0, 0);
      }
      if (this.triangleVertexColorBuffer.numItems > 0) {
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.triangleVertexColorBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, this.triColorVertices.subarray(0, this.triangleVertexColorBuffer.numItems * this.triangleVertexColorBuffer.itemSize), this.gl.STATIC_DRAW);
        this.gl.enableVertexAttribArray(this.core.webGL.shaderProgram.vertexColorAttribute);
        this.gl.vertexAttribPointer(this.core.webGL.shaderProgram.vertexColorAttribute, this.triangleVertexColorBuffer.itemSize, this.gl.UNSIGNED_BYTE, true, 0, 0);
      }
      if (this.triangleVertexTextureCoordBuffer.numItems > 0) {
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.triangleVertexTextureCoordBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, this.triTextureCoords.subarray(0, this.triangleVertexTextureCoordBuffer.numItems * this.triangleVertexTextureCoordBuffer.itemSize), this.gl.STATIC_DRAW);
        this.gl.enableVertexAttribArray(this.core.webGL.shaderProgram.textureCoordAttribute);
        this.gl.vertexAttribPointer(this.core.webGL.shaderProgram.textureCoordAttribute, this.triangleVertexTextureCoordBuffer.itemSize, this.gl.FLOAT, false, 0, 0);
        tile = this.textureTile[tileno];
        tileWidth = ((tile.lrs >> 2) + 1) - tile.uls;
        tileHeight = ((tile.lrt >> 2) + 1) - tile.ult;
        tData = void 0;
        if (tileWidth > 0 && tileHeight > 0) {
          tData = this.renderer.formatTexture(tile, this.tmem, this);
        }
        if (tData !== void 0 && tData.textureData !== void 0) {
          textureData = tData.textureData;
          this.gl.activeTexture(this.gl.TEXTURE0 + tileno);
          this.gl.bindTexture(this.gl.TEXTURE_2D, this.colorsTexture0);
          wrapS = this.gl.REPEAT;
          wrapT = this.gl.REPEAT;
          if ((tile.cms === consts.RDP_TXT_CLAMP) || (tile.masks === 0)) {
            wrapS = this.gl.CLAMP_TO_EDGE;
          } else if (tile.cms === consts.RDP_TXT_MIRROR) {
            wrapS = this.gl.MIRRORED_REPEAT;
          }
          if ((tile.cmt === consts.RDP_TXT_CLAMP) || (tile.maskt === 0)) {
            wrapT = this.gl.CLAMP_TO_EDGE;
          } else if (tile.cmt === consts.RDP_TXT_MIRROR) {
            wrapT = this.gl.MIRRORED_REPEAT;
          }
          this.gl.texParameterf(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, wrapS);
          this.gl.texParameterf(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, wrapT);
          this.gl.texParameterf(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
          this.gl.texParameterf(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
          this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, tileWidth, tileHeight, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, textureData);
        }
        // if @primColor.length > 0
        //   @gl.uniform4fv @core.webGL.shaderProgram.uPrimColor, @primColor

        // if @fillColor.length > 0
        //   @gl.uniform4fv @core.webGL.shaderProgram.uFillColor, @fillColor

        // if @blendColor.length > 0
        //   @gl.uniform4fv @core.webGL.shaderProgram.uBlendColor, @blendColor

        // if @envColor.length > 0
        //   @gl.uniform4fv @core.webGL.shaderProgram.uEnvColor, @envColor

        // if isFillRect is true
        //   @cycleType = 3

        //@gl.uniform1i @core.webGL.shaderProgram.otherModeL, @otherModeL
        //@gl.uniform1i @core.webGL.shaderProgram.otherModeH, @otherModeH
        this.gl.uniform1i(this.core.webGL.shaderProgram.cycleType, this.cycleType);
        this.gl.uniform1i(this.core.webGL.shaderProgram.uAlphaTestEnabled, this.alphaTestEnabled);
        // Matrix Uniforms
        this.gl.uniformMatrix4fv(this.core.webGL.shaderProgram.pMatrixUniform, false, this.gRSP.projectionMtxs[this.gRSP.projectionMtxTop]);
        this.gl.uniformMatrix4fv(this.core.webGL.shaderProgram.mvMatrixUniform, false, this.gRSP.modelviewMtxs[this.gRSP.modelViewMtxTop]);
        if (this.triangleVertexPositionBuffer.numItems > 0) {
          if (this.core.settings.wireframe === true) {
            this.gl.drawArrays(this.gl.LINES, 0, this.triangleVertexPositionBuffer.numItems);
          } else {
            this.gl.drawArrays(this.gl.TRIANGLES, 0, this.triangleVertexPositionBuffer.numItems);
          }
        }
      }
      this.triangleVertexPositionBuffer.numItems = 0;
      this.triangleVertexColorBuffer.numItems = 0;
      this.triangleVertexTextureCoordBuffer.numItems = 0;
      this.gRSP.numVertices = 0;
    }

    resetState() {
      this.geometryMode = 0;
      this.initGeometryMode();
      this.alphaTestEnabled = 0;
      this.activeTile = 0;
    }

    initBuffers() {
      this.triangleVertexPositionBuffer = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.triangleVertexPositionBuffer);
      this.triangleVertexPositionBuffer.itemSize = 4;
      this.triangleVertexPositionBuffer.numItems = 0;
      this.triangleVertexColorBuffer = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.triangleVertexColorBuffer);
      this.triangleVertexColorBuffer.itemSize = 4;
      this.triangleVertexColorBuffer.numItems = 0;
      this.triangleVertexTextureCoordBuffer = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.triangleVertexTextureCoordBuffer);
      this.triangleVertexTextureCoordBuffer.itemSize = 2;
      this.triangleVertexTextureCoordBuffer.numItems = 0;
    }

  };

  //hack global space until we export classes properly
  //node.js uses exports; browser uses this (window)
  root = typeof exports !== "undefined" && exports !== null ? exports : self;

  root.C1964jsVideoHLE = C1964jsVideoHLE;

}).call(this);
